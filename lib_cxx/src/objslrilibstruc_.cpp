/* $Id: objslrilibstruc_.cpp,v 1.2 2003/09/30 18:06:17 haocl Exp $
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 * File Description:
 *   This code is generated by application DATATOOL
 *   using specifications from the data definition file
 *   'slrilibstruc.asn'.
 *
 * ATTENTION:
 *   Don't edit or check-in this file to the CVS as this file will
 *   be overridden (by DATATOOL) without warning!
 * ===========================================================================
 */

// standard includes
#include <serial/serialimpl.hpp>

// generated includes
#include <objslrilibstruc.hpp>
#include <objects/mmdb1/Biostruc.hpp>
#include <objects/seq/Bioseq.hpp>
#include <objects/seqalign/Seq_align.hpp>
#include <objects/seqloc/Seq_id.hpp>
#include <objects/seqset/Bioseq_set.hpp>
#include <objects/seqset/Seq_entry.hpp>
#include <objslrilibstruc.hpp>
BEGIN_slri_SCOPE // namespace slri::


// generated classes

void CSLRIValNode_Base::Reset(void)
{
    m_data.clear();
    m_set_State[0] &= ~0x3;
}

BEGIN_NAMED_BASE_IMPLICIT_CLASS_INFO("SLRIValNode", CSLRIValNode)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_MEMBER("", m_data, STL_list, (STL_CRef, (CLASS, (CSLRINode))))->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CSLRIValNode_Base::CSLRIValNode_Base(void)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CSLRIValNode_Base::~CSLRIValNode_Base(void)
{
}


void CSLRISeq_id_Base::Reset(void)
{
    m_data.clear();
    m_set_State[0] &= ~0x3;
}

BEGIN_NAMED_BASE_IMPLICIT_CLASS_INFO("SLRISeq-id", CSLRISeq_id)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_MEMBER("", m_data, STL_list, (STL_CRef, (CLASS, (NCBI_NS_NCBI::objects::CSeq_id))))->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CSLRISeq_id_Base::CSLRISeq_id_Base(void)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CSLRISeq_id_Base::~CSLRISeq_id_Base(void)
{
}


void CSLRINode_Base::Reset(void)
{
    switch ( m_choice ) {
    case e_Accession:
        delete m_string;
        break;
    case e_Bioseq:
    case e_Biostruc:
    case e_Fasta:
    case e_Seqid:
    case e_Domain:
    case e_Seqalign:
    case e_Bioseqset:
    case e_Seqentry:
        m_object->RemoveReference();
        break;
    default:
        break;
    }
    m_choice = e_not_set;
}

void CSLRINode_Base::DoSelect(E_Choice index)
{
    switch ( index ) {
    case e_Gi:
        m_Gi = 0;
        break;
    case e_Bioseq:
        (m_object = new ncbi::objects::CBioseq())->AddReference();
        break;
    case e_Biostruc:
        (m_object = new ncbi::objects::CBiostruc())->AddReference();
        break;
    case e_Fasta:
        (m_object = new slri::CSLRIFasta())->AddReference();
        break;
    case e_Seqid:
        (m_object = new slri::CSLRISeq_id())->AddReference();
        break;
    case e_Domain:
        (m_object = new slri::CSLRIDomain())->AddReference();
        break;
    case e_Seqalign:
        (m_object = new ncbi::objects::CSeq_align())->AddReference();
        break;
    case e_Bioseqset:
        (m_object = new ncbi::objects::CBioseq_set())->AddReference();
        break;
    case e_Seqentry:
        (m_object = new ncbi::objects::CSeq_entry())->AddReference();
        break;
    case e_Accession:
        m_string = new NCBI_NS_STD::string;
        break;
    default:
        break;
    }
    m_choice = index;
}

const char* const CSLRINode_Base::sm_SelectionNames[] = {
    "not set",
    "gi",
    "accession",
    "bioseq",
    "biostruc",
    "fasta",
    "seqid",
    "domain",
    "seqalign",
    "bioseqset",
    "seqentry"
};

NCBI_NS_STD::string CSLRINode_Base::SelectionName(E_Choice index)
{
    return NCBI_NS_NCBI::CInvalidChoiceSelection::GetName(index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

void CSLRINode_Base::ThrowInvalidSelection(E_Choice index) const
{
    throw NCBI_NS_NCBI::CInvalidChoiceSelection(__FILE__,__LINE__,m_choice, index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

const NCBI_NS_NCBI::objects::CBioseq& CSLRINode_Base::GetBioseq(void) const
{
    CheckSelected(e_Bioseq);
    return *static_cast<const TBioseq*>(m_object);
}

NCBI_NS_NCBI::objects::CBioseq& CSLRINode_Base::SetBioseq(void)
{
    Select(e_Bioseq, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TBioseq*>(m_object);
}

void CSLRINode_Base::SetBioseq(NCBI_NS_NCBI::objects::CBioseq& value)
{
    TBioseq* ptr = &value;
    if ( m_choice != e_Bioseq || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Bioseq;
    }
}

const NCBI_NS_NCBI::objects::CBiostruc& CSLRINode_Base::GetBiostruc(void) const
{
    CheckSelected(e_Biostruc);
    return *static_cast<const TBiostruc*>(m_object);
}

NCBI_NS_NCBI::objects::CBiostruc& CSLRINode_Base::SetBiostruc(void)
{
    Select(e_Biostruc, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TBiostruc*>(m_object);
}

void CSLRINode_Base::SetBiostruc(NCBI_NS_NCBI::objects::CBiostruc& value)
{
    TBiostruc* ptr = &value;
    if ( m_choice != e_Biostruc || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Biostruc;
    }
}

const CSLRIFasta& CSLRINode_Base::GetFasta(void) const
{
    CheckSelected(e_Fasta);
    return *static_cast<const TFasta*>(m_object);
}

CSLRIFasta& CSLRINode_Base::SetFasta(void)
{
    Select(e_Fasta, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TFasta*>(m_object);
}

void CSLRINode_Base::SetFasta(CSLRIFasta& value)
{
    TFasta* ptr = &value;
    if ( m_choice != e_Fasta || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Fasta;
    }
}

const CSLRISeq_id& CSLRINode_Base::GetSeqid(void) const
{
    CheckSelected(e_Seqid);
    return *static_cast<const TSeqid*>(m_object);
}

CSLRISeq_id& CSLRINode_Base::SetSeqid(void)
{
    Select(e_Seqid, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TSeqid*>(m_object);
}

void CSLRINode_Base::SetSeqid(CSLRISeq_id& value)
{
    TSeqid* ptr = &value;
    if ( m_choice != e_Seqid || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Seqid;
    }
}

const CSLRIDomain& CSLRINode_Base::GetDomain(void) const
{
    CheckSelected(e_Domain);
    return *static_cast<const TDomain*>(m_object);
}

CSLRIDomain& CSLRINode_Base::SetDomain(void)
{
    Select(e_Domain, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TDomain*>(m_object);
}

void CSLRINode_Base::SetDomain(CSLRIDomain& value)
{
    TDomain* ptr = &value;
    if ( m_choice != e_Domain || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Domain;
    }
}

const NCBI_NS_NCBI::objects::CSeq_align& CSLRINode_Base::GetSeqalign(void) const
{
    CheckSelected(e_Seqalign);
    return *static_cast<const TSeqalign*>(m_object);
}

NCBI_NS_NCBI::objects::CSeq_align& CSLRINode_Base::SetSeqalign(void)
{
    Select(e_Seqalign, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TSeqalign*>(m_object);
}

void CSLRINode_Base::SetSeqalign(NCBI_NS_NCBI::objects::CSeq_align& value)
{
    TSeqalign* ptr = &value;
    if ( m_choice != e_Seqalign || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Seqalign;
    }
}

const NCBI_NS_NCBI::objects::CBioseq_set& CSLRINode_Base::GetBioseqset(void) const
{
    CheckSelected(e_Bioseqset);
    return *static_cast<const TBioseqset*>(m_object);
}

NCBI_NS_NCBI::objects::CBioseq_set& CSLRINode_Base::SetBioseqset(void)
{
    Select(e_Bioseqset, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TBioseqset*>(m_object);
}

void CSLRINode_Base::SetBioseqset(NCBI_NS_NCBI::objects::CBioseq_set& value)
{
    TBioseqset* ptr = &value;
    if ( m_choice != e_Bioseqset || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Bioseqset;
    }
}

const NCBI_NS_NCBI::objects::CSeq_entry& CSLRINode_Base::GetSeqentry(void) const
{
    CheckSelected(e_Seqentry);
    return *static_cast<const TSeqentry*>(m_object);
}

NCBI_NS_NCBI::objects::CSeq_entry& CSLRINode_Base::SetSeqentry(void)
{
    Select(e_Seqentry, NCBI_NS_NCBI::eDoNotResetVariant);
    return *static_cast<TSeqentry*>(m_object);
}

void CSLRINode_Base::SetSeqentry(NCBI_NS_NCBI::objects::CSeq_entry& value)
{
    TSeqentry* ptr = &value;
    if ( m_choice != e_Seqentry || m_object != ptr ) {
        Reset();
        (m_object = ptr)->AddReference();
        m_choice = e_Seqentry;
    }
}

// helper methods

// type info
BEGIN_NAMED_BASE_CHOICE_INFO("SLRINode", CSLRINode)
{
    SET_CHOICE_MODULE("SLRILIB-struc");
    ADD_NAMED_STD_CHOICE_VARIANT("gi", m_Gi);
    ADD_NAMED_PTR_CHOICE_VARIANT("accession", m_string, STD, (NCBI_NS_STD::string));
    ADD_NAMED_REF_CHOICE_VARIANT("bioseq", m_object, NCBI_NS_NCBI::objects::CBioseq);
    ADD_NAMED_REF_CHOICE_VARIANT("biostruc", m_object, NCBI_NS_NCBI::objects::CBiostruc);
    ADD_NAMED_REF_CHOICE_VARIANT("fasta", m_object, CSLRIFasta);
    ADD_NAMED_REF_CHOICE_VARIANT("seqid", m_object, CSLRISeq_id);
    ADD_NAMED_REF_CHOICE_VARIANT("domain", m_object, CSLRIDomain);
    ADD_NAMED_REF_CHOICE_VARIANT("seqalign", m_object, NCBI_NS_NCBI::objects::CSeq_align);
    ADD_NAMED_REF_CHOICE_VARIANT("bioseqset", m_object, NCBI_NS_NCBI::objects::CBioseq_set);
    ADD_NAMED_REF_CHOICE_VARIANT("seqentry", m_object, NCBI_NS_NCBI::objects::CSeq_entry);
}
END_CHOICE_INFO

// constructor
CSLRINode_Base::CSLRINode_Base(void)
    : m_choice(e_not_set)
{
}

// destructor
CSLRINode_Base::~CSLRINode_Base(void)
{
    if ( m_choice != e_not_set )
        Reset();
}


void CSLRIFasta_Base::ResetDefline(void)
{
    m_Defline.erase();
    m_set_State[0] &= ~0x3;
}

void CSLRIFasta_Base::ResetSequence(void)
{
    m_Sequence.erase();
    m_set_State[0] &= ~0xc;
}

void CSLRIFasta_Base::Reset(void)
{
    ResetDefline();
    ResetSequence();
}

BEGIN_NAMED_BASE_CLASS_INFO("SLRIFasta", CSLRIFasta)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_STD_MEMBER("defline", m_Defline)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_STD_MEMBER("sequence", m_Sequence)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CSLRIFasta_Base::CSLRIFasta_Base(void)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CSLRIFasta_Base::~CSLRIFasta_Base(void)
{
}


void CSLRIDomain_Base::Reset(void)
{
    ResetGi();
    ResetFrom();
    ResetTo();
}

BEGIN_NAMED_BASE_CLASS_INFO("SLRIDomain", CSLRIDomain)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_STD_MEMBER("gi", m_Gi)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_STD_MEMBER("from", m_From)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_STD_MEMBER("to", m_To)->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CSLRIDomain_Base::CSLRIDomain_Base(void)
    : m_Gi(0), m_From(0), m_To(0)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CSLRIDomain_Base::~CSLRIDomain_Base(void)
{
}


void CDTree_Base::Reset(void)
{
    m_data.clear();
    m_set_State[0] &= ~0x3;
}

BEGIN_NAMED_BASE_IMPLICIT_CLASS_INFO("DTree", CDTree)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_MEMBER("", m_data, STL_list, (STL_CRef, (CLASS, (CDNode))))->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CDTree_Base::CDTree_Base(void)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CDTree_Base::~CDTree_Base(void)
{
}


BEGIN_NAMED_ENUM_IN_INFO("", CDNode_Base::, EState, false)
{
    ADD_ENUM_VALUE("none", eState_none);
    ADD_ENUM_VALUE("vis", eState_vis);
}
END_ENUM_INFO

void CDNode_Base::ResetKey(void)
{
    (*m_Key).Reset();
}

void CDNode_Base::SetKey(CDKey& value)
{
    m_Key.Reset(&value);
}

void CDNode_Base::ResetData(void)
{
    m_Data.Reset();
}

void CDNode_Base::SetData(CDData& value)
{
    m_Data.Reset(&value);
}

CDData& CDNode_Base::SetData(void)
{
    if ( !m_Data )
        m_Data.Reset(new slri::CDData());
    return (*m_Data);
}

void CDNode_Base::ResetP(void)
{
    m_P.clear();
    m_set_State[0] &= ~0x300;
}

void CDNode_Base::ResetC(void)
{
    m_C.clear();
    m_set_State[0] &= ~0xc00;
}

void CDNode_Base::Reset(void)
{
    ResetKey();
    ResetData();
    ResetNum();
    ResetState();
    ResetP();
    ResetC();
}

BEGIN_NAMED_BASE_CLASS_INFO("DNode", CDNode)
{
    SET_CLASS_MODULE("SLRILIB-struc");
    ADD_NAMED_REF_MEMBER("key", m_Key, CDKey);
    ADD_NAMED_REF_MEMBER("data", m_Data, CDData)->SetOptional();
    ADD_NAMED_STD_MEMBER("num", m_Num)->SetOptional()->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_ENUM_MEMBER("state", m_State, EState)->SetDefault(new TState(eState_none))->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_MEMBER("p", m_P, STL_list, (STL_CRef, (CLASS, (CDNode))))->SetOptional()->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    ADD_NAMED_MEMBER("c", m_C, STL_list, (STL_CRef, (CLASS, (CDNode))))->SetOptional()->SetSetFlag(MEMBER_PTR(m_set_State[0]));
    info->RandomOrder();
}
END_CLASS_INFO

// constructor
CDNode_Base::CDNode_Base(void)
    : m_Key(new slri::CDKey()), m_Num(0), m_State(eState_none)
{
    memset(m_set_State,0,sizeof(m_set_State));
}

// destructor
CDNode_Base::~CDNode_Base(void)
{
}


void CDKey_Base::Reset(void)
{
    switch ( m_choice ) {
    case e_Str:
        delete m_string;
        break;
    default:
        break;
    }
    m_choice = e_not_set;
}

void CDKey_Base::DoSelect(E_Choice index)
{
    switch ( index ) {
    case e_Id:
        m_Id = 0;
        break;
    case e_Real:
        m_Real = 0;
        break;
    case e_Str:
        m_string = new NCBI_NS_STD::string;
        break;
    default:
        break;
    }
    m_choice = index;
}

const char* const CDKey_Base::sm_SelectionNames[] = {
    "not set",
    "id",
    "str",
    "real"
};

NCBI_NS_STD::string CDKey_Base::SelectionName(E_Choice index)
{
    return NCBI_NS_NCBI::CInvalidChoiceSelection::GetName(index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

void CDKey_Base::ThrowInvalidSelection(E_Choice index) const
{
    throw NCBI_NS_NCBI::CInvalidChoiceSelection(__FILE__,__LINE__,m_choice, index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

// helper methods

// type info
BEGIN_NAMED_BASE_CHOICE_INFO("DKey", CDKey)
{
    SET_CHOICE_MODULE("SLRILIB-struc");
    ADD_NAMED_STD_CHOICE_VARIANT("id", m_Id);
    ADD_NAMED_PTR_CHOICE_VARIANT("str", m_string, STD, (NCBI_NS_STD::string));
    ADD_NAMED_STD_CHOICE_VARIANT("real", m_Real);
}
END_CHOICE_INFO

// constructor
CDKey_Base::CDKey_Base(void)
    : m_choice(e_not_set)
{
}

// destructor
CDKey_Base::~CDKey_Base(void)
{
    if ( m_choice != e_not_set )
        Reset();
}


void CDData_Base::Reset(void)
{
    switch ( m_choice ) {
    case e_Os:
        delete m_Os;
        break;
    case e_Strs:
        delete m_Strs;
        break;
    case e_Ids:
        delete m_Ids;
        break;
    case e_Reals:
        delete m_Reals;
        break;
    case e_Oss:
        {
            for ( std::list< std::vector< char >* >::iterator listIter1 = (*m_Oss).begin(); listIter1 != (*m_Oss).end(); ++listIter1 ) {
                delete (*listIter1);
            }
        }
        delete m_Oss;
        break;
    case e_Data_list:
        delete m_Data_list;
        break;
    case e_Str:
    case e_Gen_memfree:
        delete m_string;
        break;
    default:
        break;
    }
    m_choice = e_not_set;
}

void CDData_Base::DoSelect(E_Choice index)
{
    switch ( index ) {
    case e_Id:
        m_Id = 0;
        break;
    case e_Real:
        m_Real = 0;
        break;
    case e_Bool:
        m_Bool = 0;
        break;
    case e_Os:
        m_Os = new std::vector< char >();
        break;
    case e_Strs:
        m_Strs = new std::list< std::string >();
        break;
    case e_Ids:
        m_Ids = new std::list< int >();
        break;
    case e_Reals:
        m_Reals = new std::list< double >();
        break;
    case e_Oss:
        m_Oss = new std::list< std::vector< char >* >();
        break;
    case e_Data_list:
        m_Data_list = new std::list< ncbi::CRef< slri::CDData > >();
        break;
    case e_User_def:
        m_User_def = true;
        break;
    case e_Str:
    case e_Gen_memfree:
        m_string = new NCBI_NS_STD::string;
        break;
    default:
        break;
    }
    m_choice = index;
}

const char* const CDData_Base::sm_SelectionNames[] = {
    "not set",
    "id",
    "str",
    "real",
    "bool",
    "os",
    "strs",
    "ids",
    "reals",
    "oss",
    "gen-memfree",
    "data-list",
    "user-def"
};

NCBI_NS_STD::string CDData_Base::SelectionName(E_Choice index)
{
    return NCBI_NS_NCBI::CInvalidChoiceSelection::GetName(index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

void CDData_Base::ThrowInvalidSelection(E_Choice index) const
{
    throw NCBI_NS_NCBI::CInvalidChoiceSelection(__FILE__,__LINE__,m_choice, index, sm_SelectionNames, sizeof(sm_SelectionNames)/sizeof(sm_SelectionNames[0]));
}

// helper methods

// type info
BEGIN_NAMED_BASE_CHOICE_INFO("DData", CDData)
{
    SET_CHOICE_MODULE("SLRILIB-struc");
    ADD_NAMED_STD_CHOICE_VARIANT("id", m_Id);
    ADD_NAMED_PTR_CHOICE_VARIANT("str", m_string, STD, (NCBI_NS_STD::string));
    ADD_NAMED_STD_CHOICE_VARIANT("real", m_Real);
    ADD_NAMED_STD_CHOICE_VARIANT("bool", m_Bool);
    ADD_NAMED_PTR_CHOICE_VARIANT("os", m_Os, STL_CHAR_vector, (char));
    ADD_NAMED_PTR_CHOICE_VARIANT("strs", m_Strs, STL_list, (STD, (NCBI_NS_STD::string)));
    ADD_NAMED_PTR_CHOICE_VARIANT("ids", m_Ids, STL_list, (STD, (int)));
    ADD_NAMED_PTR_CHOICE_VARIANT("reals", m_Reals, STL_list, (STD, (double)));
    ADD_NAMED_PTR_CHOICE_VARIANT("oss", m_Oss, STL_list, (POINTER, (STL_CHAR_vector, (char))));
    ADD_NAMED_PTR_CHOICE_VARIANT("gen-memfree", m_string, STD, (NCBI_NS_STD::string));
    ADD_NAMED_PTR_CHOICE_VARIANT("data-list", m_Data_list, STL_list, (STL_CRef, (CLASS, (CDData))));
    ADD_NAMED_CHOICE_VARIANT("user-def", m_User_def, null, ());
}
END_CHOICE_INFO

// constructor
CDData_Base::CDData_Base(void)
    : m_choice(e_not_set)
{
}

// destructor
CDData_Base::~CDData_Base(void)
{
    if ( m_choice != e_not_set )
        Reset();
}



END_slri_SCOPE // namespace slri::

