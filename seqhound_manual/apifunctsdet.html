<br><br><h1><a name=SECTIONID_19>SYSTEM INITIALIZATION, FINISHING AND TESTING</a></h1><br><br>Functions in this group will be used by all SeqHound API
programs to open a connection to SeqHound at the beginning of the program and to close the connection at the end of the program.<br><br>





<br><h2><a name=SHoundFini>SHoundFini</a></h2>

<br><b>description: </b>Closes the SeqHound system and the NCBI NetEntrez service if it has been initialized.<br>


<br><br><b>C</b><br>

<b>arguments: </b>void<br>
<b>return: </b>void<br>
<b>prototype: </b>void SHoundFini(void);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>void<br>
<b>return: </b>void<br>
<b>prototype: </b>void SHoundFini(void);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>none<br>
<b>return: </b>none<br>

<b>example: </b>SHoundFini();<br>
<a href=apifunctslist.html#SHoundFini>list of functions</a><br><br>

<br><h2><a name=SHoundInit>SHoundInit</a></h2>
<br><b>description: </b>Initializes the SeqHound system; checks if the server is ready for querying. NCBI NetEntrez service can be
initialized simultaneously if the user desires to query obsolete (outdated) sequences.<br>



<br><br><b>C</b><br>
<b>arguments: </b>boolean value indicating if the user wants to initialize NetEntrez service (acceptable values: TRUE/FALSE); pointer to a string
containing current  application name<br>
<b>return: </b>boolean TRUE if success or FALSE (in this case do not continue querying SeqHound)<br>

<b>prototype: </b>Boolean SHoundInit(Boolean NetEntrezOnToo, CharPtr appname);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>boolean value indicating if the user wants to initialize NetEntrez service (acceptable values: true/false); string containing current
application  name<br>
<b>return: </b>boolean true if success or false (in this case do not continue querying SeqHound)<br>

<b>prototype: </b>bool SHoundInit(bool NetEntrezOnToo, string appname);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>boolean value indicating if the user wants to initialize NetEntrez service (acceptable values: "TRUE"/"FALSE"); current application
name<br>
<b>return: </b>"TRUE" if success or "FALSE" (in this case do not continue querying SeqHound)<br>

<b>example: </b>SHoundInit("FALSE", "myapp");<br>
<a href=apifunctslist.html#SHoundInit>list of functions</a><br><br>

<br><h2><a name=SHoundIsInited>SHoundIsInited</a></h2>
<br><b>description: </b>Reports if SeqHound has been initialized.<br>


<br><br><b>C</b><br>
<b>arguments: </b>void<br>
<b>return: </b>boolean TRUE if success or FALSE<br>

<b>prototype: </b>Boolean SHoundIsInited(void);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>void<br>

<b>return: </b>boolean true if success or false<br>
<b>prototype: </b>bool SHoundIsInited(void);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>none<br>
<b>return: </b>"TRUE" if success or "FALSE"<br>
<b>example: </b>$result = SHoundIsInited();<br>

<a href=apifunctslist.html#SHoundIsInited>list of functions</a><br><br>
<br><h2><a name=SHoundIsNetEntrezOn>SHoundIsNetEntrezOn</a></h2>

<br><b>description: </b>Finds out if NCBI NetEnrez service has been initialized. NCBI NetEntrez service can be used to query obsolete
(outdated)  sequences.<br>

<br><br><b>C</b><br>

<b>arguments: </b>void<br>
<b>return: </b>boolean TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundIsNetEntrezOn(void);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>void<br>
<b>return: </b>boolean true if success or false<br>

<b>prototype: </b>bool SHoundIsNetEntrezOn(void);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>none<br>

<b>return: </b>"TRUE" if success or "FALSE"<br>
<b>example: </b>SHoundIsNetEntrezOn();<br>
<a href=apifunctslist.html#SHoundIsNetEntrezOn>list of functions</a><br><br>

<br><h2><a name=SHoundNetEntrezInit>SHoundNetEntrezInit</a></h2>

<br><b>description: </b>Initializes the SeqHound system together with NCBI NetEntrez service. NCBI NetEntrez service can be used to
query obsolete (outdated) sequences.<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing application name<br>

<b>return: </b>boolean TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundNetEntrezInit(CharPtr appname);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>string containing application name<br>
<b>return: </b>boolean true if success or false<br>
<b>prototype: </b>bool SHoundNetEntrezInit(const string appname);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>application name<br>
<b>return: </b>"TRUE" if success or "FALSE"<br>

<b>example: </b>SHoundNetEntrezInit("myapp");<br>
<a href=apifunctslist.html#SHoundNetEntrezInit>list of functions</a><br><br>
<br><br><h1><a name=SECTIONID_17>GENBANK ID CONVERSIONS</a></h1><br><br>GenBank sequence records are associated with three types of identifiers; Gene Info
identifiers (GI), GenBank accessions and other identifiers kept in the record's "seq-id".  These functions may be used to convert between these three types
 of identifiers.  While most people are familiar with the Genbank accession and GI identifiers,  GenBank may also keep identifiers that denote the source
database and identifier used by GenBank to construct the record (for example embl or pir specific accessions or Blattner identifiers (BLATT)).  These
identifiers are usually not displayed in the GenBank flat-file but are present in the underlying ASN.1 of the record in the seq-id structure.  You can read
 more about this structure by going to http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SB/hbr.html and entering "seq-id" in the query box or by searching for "seq
{ id {" in the ASN.1 format of a GenBank record.  A complete list of the dbnames and example identifiers that may be used with these functions is listed in
 the API supplementary information page.
It should be noted that there is a conceptual difference between functions in this section and those in the DBXref module.  Conversion between GI's,
Accessions and "other" database identifiers are conversions between identifiers that point to exactly the same sequence record.  In contrast, database
cross-references found in source records (see DbXref module) may refer to other things (for example, annotations on or records related to the source
record).<br><br>





















<br><h2><a name=SHoundDbNameAndIdListFromGBAcc>SHoundDbNameAndIdListFromGBAcc</a></h2>

<br><b>description: </b>This function takes a GenBank accession and retrieves all of the Database name and Id pairs that are present in
the seq-id portion of the corresponding GenBank record.  For additional information, see the description beneath the section header for
this group of functions (Genbank ID Conversions).<br>


<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundDbNameAndIdListFromGBAc
c(java.lang.String)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>
<a href=apifunctslist.html#SHoundDbNameAndIdListFromGBAcc>list of functions</a><br><br>

<br><h2><a name=SHoundDbNameAndIdListFromGBAccKeyedList>SHoundDbNameAndIdListFromGBAccKeyedList</a></h2>

<br><b>description: </b>This function takes a list of GenBank accessions and retrieves all of the Database name and Id pairs that are
present in the seq-id portion of the corresponding GenBank record.  For additional information, see the description beneath the section
header for this group of functions (Genbank ID Conversions).  The returned structure maps queries with their corresponding database
names and identifiers.<br>


<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundDbNameAndIdListFromGBAc
cKeyedList(org.blueprint.seqhound.biobeans.ShAccList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundDbNameAndIdListFromGBAccKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundDbNameAndIdListFromGi>SHoundDbNameAndIdListFromGi</a></h2>

<br><b>description: </b>This function takes a Gene Info (GI) identifier and retrieves all of the Database name and Id pairs that are
present in the seq-id portion of the corresponding GenBank record.  For additional information, see the description beneath the section
header for this group of functions (Genbank ID Conversions).<br>



<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundDbNameAndIdListFromGi(j
ava.lang.Integer)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>
<a href=apifunctslist.html#SHoundDbNameAndIdListFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundDbNameAndIdListFromGiKeyedList>SHoundDbNameAndIdListFromGiKeyedList</a></h2>
<br><b>description: </b>This function takes a list of Gene Info (GI) identifiers and retrieves all of the Database name and Id pairs
that are present in the seq-id portion of the corresponding GenBank record.  For additional information, see the description beneath the
 section header for this group of functions (Genbank ID Conversions).  The returned structure pairs the queries with their corresponding
 results.<br>


<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundDbNameAndIdListFromGiKe
yedList(org.blueprint.seqhound.biobeans.ShGiList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundDbNameAndIdListFromGiKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundGBAccFromDbNameAndId>SHoundGBAccFromDbNameAndId</a></h2>
<br><b>description: </b>This function takes a database name and identifier found in a GenBank sequence record (in the seq-id) and
returns the corresponding GenBank accession. For additional information, see the description beneath the section header for this group
of functions (Genbank ID Conversions).<br>
<b>comment: </b>Note that EMBL shares accession numbers with GenBank; for example, accession X13776. EMBL also has its own identifiers
(which are maintained by GenBank in the seq-id portion of the GenBank record). So, for instance, this function would return accession
X13776 if queried with the DbName "embl" and the Id "PAAMIR".

Note: if the DbName is "pdb" this function needs the "chain" parameter to be specified.<br>
<br><br><b>Java</b><br>

<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGBAccFromDbNameAndId(ja
va.lang.String,%20java.lang.String,%20java.lang.String)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGBAccFromDbNameAndId>list of functions</a><br><br>
<br><h2><a name=SHoundGBAccFromDbNameAndIdKeyedList>SHoundGBAccFromDbNameAndIdKeyedList</a></h2>

<br><b>description: </b>This function takes a list of database name and identifier pairs found in a GenBank sequence record (in the
seq-id) and returns the corresponding GenBank accession. For additional information, see the description beneath the section header for
this group of functions (Genbank ID Conversions).<br>
<b>comment: </b>Note that EMBL shares accession numbers with GenBank; for example, accession X13776. EMBL also has its own identifiers
(which are maintained by GenBank in the seq-id portion of the GenBank record). So, for instance, this function would return accession
X13776 if queried with the DbName "embl" and the Id "PAAMIR".

Note: if the DbName is "pdb" this function needs the "chain" parameter to be specified.<br>
<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundDbNameAndIdListFromGBAc
cKeyedList(org.blueprint.seqhound.biobeans.ShAccList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>


<a href=apifunctslist.html#SHoundGBAccFromDbNameAndIdKeyedList>list of functions</a><br><br>
<br><h2><a name=SHoundGBAccFromGi>SHoundGBAccFromGi</a></h2>

<br><b>description: </b>Converts a GI identifier to a GenBank accession number.<br>

<b>comment: </b>Sequences from the PIR or PDB databases will return "n/a" for this function since they do not have a GenBank accession.
Instead, use SHoundDbNameAndIdFromGi to retrieve the corresponding pir or pdb accession.<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGBAccFromGi(java.lang.I
nteger)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>
<a href=apifunctslist.html#SHoundGBAccFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundGBAccFromGiKeyedList>SHoundGBAccFromGiKeyedList</a></h2>

<br><b>description: </b>Converts a list of GI identifiers to GenBank accessions.  The returned structure maps queries with their
corresponding accessions.<br>
<b>comment: </b>Sequences from the PIR or PDB databases will return "n/a" for this function since they do not have a GenBank accession.
Use SHoundDbNameAndIdFromGi to retrieve accessions for the corresponding pir or pdb GI's.<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGBAccFromGiKeyedList(or
g.blueprint.seqhound.biobeans.ShGiList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGBAccFromGiKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundGetAccFromRetiredGi>SHoundGetAccFromRetiredGi</a></h2>

<br><b>description: </b>Converts a retired GI identifier to an NCBI accession number.<br>
<b>comment: </b>This function will only work if the GI identifier was retired since the public version of SeqHound was instantiated.
SeqHound only keeps the most up to date versions of GenBank sequences.  It keeps a local history of retired GI's.

For more complete access to historical GI's, developers are directed to the ID1_Fetch utility of the NCBI C++ toolkit (see
http://www.ncbi.nlm.nih.gov/books/bv.fcgi?rid=toolkit.section.3571) or NCBI's eutils (see
http://eutils.ncbi.nlm.nih.gov/entrez/query/static/efetchseq_help.html).  An example call to retrieve the accession for a retired GI
would be:
http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein&id=17402729&retmode=text&rettype=acc (if you knew that GI 17402729
was retired.
The returned accession (actually a version id is returned and you have to remove the .1 yourself) is AC104281.  This accession can be
used to retrieve the GI of the most up to date version of the sequence from SeqHound (see SHoundGiFromGBAcc or SHoundFindAcc).<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>CharPtr (Accession number) or NULL on error<br>

<b>prototype: </b>CharPtr  SHoundGetAccFromRetiredGi(Int4 gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>string (kEmptyStr) or string Accession number<br>
<b>prototype: </b>string SHoundGetAccFromRetiredGi(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI (e.g. 4557628)<br>
<b>return: </b>accession or zero if failure<br>
<b>example: </b>SHoundGetAccFromRetiredGi(4557628)<br>

<a href=apifunctslist.html#SHoundGetAccFromRetiredGi>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromDbNameAndId>SHoundGiFromDbNameAndId</a></h2>

<br><b>description: </b>This function takes a database name and identifier found in a GenBank sequence record (in the seq-id) and
returns the corresponding Gene Info identifier.  See the above description under Sequence Identifier Conversions.<br>

<b>comment: </b>Note that EMBL shares accession numbers with GenBank. EMBL GenInfo identifiers may be returned using these accessions;
for example SHoundGiFromGBAcc(X13776) will return GI 45269. EMBL also has its own identifiers (which are maintained by GenBank in the
seq-id portion of the GenBank record). So the same GI may be returned using SHoundGiFromDbNameAndId with the DbName 'embl' and the Id
'PAAMIR'.

Note: if the DbName is 'pdb' this function needs the 'chain' parameter to be specified.<br>
<br><br><b>Java</b><br>

<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGiFromDbNameAndId(java.
lang.String,%20java.lang.String,%20java.lang.String)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGiFromDbNameAndId>list of functions</a><br><br>
<br><h2><a name=SHoundGiFromDbNameAndIdKeyedList>SHoundGiFromDbNameAndIdKeyedList</a></h2>

<br><b>description: </b>This function takes a list of database names and identifiers found in a GenBank sequence record (in the seq-id)
and returns the corresponding Gene Info identifier.  See the above description under Sequence Identifier Conversions.  The returned
structure maps queries with corresponding GI's.<br>

<b>comment: </b>Note that EMBL shares accession numbers with GenBank. EMBL GenInfo identifiers may be returned using these accessions;
for example SHoundGiFromGBAcc(X13776) will return GI 45269. EMBL also has its own identifiers (which are maintained by GenBank in the
seq-id portion of the GenBank record). So the same GI may be returned using SHoundGiFromDbNameAndId with the DbName 'embl' and the Id
'PAAMIR'.

Note: if the DbName is 'pdb' this function needs the 'chain' parameter to be specified.<br>
<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGiFromDbNameAndIdKeyedL
ist(org.blueprint.seqhound.biobeans.ShDbNameAndIdList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGiFromDbNameAndIdKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromGBAcc>SHoundGiFromGBAcc</a></h2>

<br><b>description: </b>Converts an accession number for a sequence to a Gene Info identifier - GI.<br>
<b>comment: </b>This function will not accept a version number (e.g. NP_116609.1). The '.1' must be removed from the example version
number to form a valid accession. SeqHound only stores and returns the latest version of a sequence record.
Note that if this function is passed a Swiss-Prot secondary identifier (as opposed to a primary identifier), it will fail.  Swiss-Prot
secondary accessions may map to more than one Swiss-Prot primary identifier (and therefore more than one GenBank accession).  Developers
are directed to the DBXref functions to deal with this type of identifier.<br>


<br><br><b>Java</b><br>
<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGiFromGBAcc(java.lang.S
tring)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGiFromGBAcc>list of functions</a><br><br>








<br><h2><a name=SHoundGiFromGBAccKeyedList>SHoundGiFromGBAccKeyedList</a></h2>

<br><b>description: </b>Converts a list of GenBank accession numbers into a list of GI identifiers.  The return structure maps the
original query accession with its corresponding GI.<br>
<b>comment: </b>This function will not accept a version number (e.g. NP_116609.1). The '.1' must be removed from the example version
number to form a valid accession. SeqHound only stores and returns the latest version of a sequence record.
Note that if this function is passed a Swiss-Prot secondary identifier (as opposed to a primary identifier), it will fail.  Swiss-Prot
secondary accessions may map to more than one Swiss-Prot primary identifier (and therefore more than one GenBank accession).  Developers
are directed to the DBXref functions to deal with this type of identifier.<br>


<br><br><b>Java</b><br>

<b>comment: </b>See the <a
href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundGenbankIDConversionInterface.html#SHoundGiFromGBAccKeyedList(or
g.blueprint.seqhound.biobeans.ShAccList)">JavaDocs</a> for the SHoundGenbankIDConversionInterface.<br>

<a href=apifunctslist.html#SHoundGiFromGBAccKeyedList>list of functions</a><br><br>
<br><h2><a name=SHoundSeqIdFromGi>SHoundSeqIdFromGi</a></h2>

<br><b>description: </b>Converts GI identifier into an ASN.1 structure seq-id which contains all available identifiers for a given
sequence.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to SeqId ASN.1 in a binary format or NULL<br>
<b>prototype: </b>SeqIdPtr SHoundSeqIdFromGi(Int4 gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to SLRISeq_id ASN.1 object in a binary format or NULL<br>

<b>prototype: </b>CSLRISeq_id *SHoundSeqIdFromGi(int Gi);<br>
<br><br><b>Java</b><br>
<b>comment: </b>Use SHoundDbNameAndIdFromGi instead.<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>
<b>return: </b>SeqId ASN.1 in text form e.g.
<br>         "SLRISeq-id ::= {
<br>                 embl {
<br>                    name "SCTRNE3A" ,
<br>                    accession "X08048" ,
<br>                    version 1 } ,
<br>                 gi 4646 }"
<br>or zero if failure<br>
<b>example: </b>SHoundSeqIdFromGi(432);<br>
<a href=apifunctslist.html#SHoundSeqIdFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundSeqIdFromGiList>SHoundSeqIdFromGiList</a></h2>

<br><b>description: </b>Converts a list of GI identifiers into an list of ASN.1 SeqId structures which contain all available identifiers
 for a given sequence.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>

<b>return: </b>pointer to a list of SeqId structures in ASN.1 a binary format or NULL<br>
<b>prototype: </b>ValNodePtr SHoundSeqIdFromGiList(ValNodePtr pnvGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of SeqId objects or NULL<br>

<b>prototype: </b>CSLRIValNode *SHoundSeqIdFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers<br>

<b>return: </b>List of SeqId structures in a parseable text form of ASN.1<br>
<b>example: </b>SHoundSeqIdFromGiList("432,543"); see also: SHoundSeqIdFromGi for example on SeqId structure<br>
<a href=apifunctslist.html#SHoundSeqIdFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundTitleFromGi>SHoundTitleFromGi</a></h2>

<br><b>description: </b>Retrieves the title ( a short description of the sequence record) for the given GI identifier<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>title<br>
<b>prototype: </b>CharPtr LIBCALL SHoundTitleFromGi(Int4 gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier<br>
<b>return: </b>title or zero if failure<br>
<b>example: </b>SHoundTitleFromGi(21071030);<br>

<a href=apifunctslist.html#SHoundTitleFromGi>list of functions</a><br><br>
<br><br><h1><a name=SECTIONID_32>DATABASE CROSS-REFERENCE CONVERSIONS (DBXREF)</a></h1><br><br>The DBXref API allows programmers to find cross-references
that are embedded in a given source record.  Conversely, given a cross-reference, a programmer can find the source records in which it is embedded.  Source
 records and cross-references are both specified by some database name and an identifier for a record in that database.  For example, a Swiss-Prot source
record can be specified by the database name 'SP' and the identifier 'P38903'.  The database cross-references found in this source record include GenBank
'GB' U06630 and 'Interpro' IPR001757 and the Saccharomyces cerevisiae database 'SGD' record S0005540.  The returned data structure (ShDxList of ShDx) that
describes the cross-references also contains information that specifies where the cross-reference was found in the source record (field) and the meaning of
 the cross-reference with respect to the source record (cv).
The DBXref module and its contents are described in further detail in section 5 of the SeqHound Manual.  A number of helper functions are also included in
this module:  SHoundGetDxDbNames will return a list of database names that can be used with this API.  SHoundDxFieldNameListFromDbName and
SHoundGetDxCvTermList will return field names and Controlled Vocabulary terms (cv) used to describe cross-references.  The DBXref data set is also
available from the SeqHound ftp site.<br><br>






















<br><h2><a name=SHoundDxFieldNameListFromDbName>SHoundDxFieldNameListFromDbName</a></h2>

<br><b>description: </b>This helper function will retrieve a set of field names that may be used with the DBXref functions.<br>

<b>comment: </b>The user may specify a single database name for which field names are to be retrieved.  If this dbname is not specified,
all field names for all databases in the DBXref module will be returned.  The structure returned consists of a list of database names
paired with field names for that database.<br>
<br><br><b>Java</b><br>

<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundDxFieldNameListFromDbName>list of functions</a><br><br>
<br><h2><a name=SHoundDxListFromGi>SHoundDxListFromGi</a></h2>

<br><b>description: </b>This convenience function is based on SHoundDxListFromSource.  The specified Gene Information identifier (GI) is
 converted to a list of GenBank accessions (considered equivalent to the query using the redundant module) and all cross-references
found in these records are returned.<br>
<b>comment: </b>See SHoundDxListFromSource.<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundDxListFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundDxListFromSource>SHoundDxListFromSource</a></h2>
<br><b>description: </b>Given a database name and identifier for some source record, retrieve a list of database cross-references found
in that record.  The returned structure (ShDxList of ShDx) describes each cross-reference as a dbname and an id.  The field in the
source record where the cross-reference was found is also returned (field) and the meaning of the cross-reference with respect to the
source record (cv) is also returned in the same structure.<br>

<b>comment: </b>dbname is a database name.  Use the helper function SHoundGetDxDbnames to retrieve a list of dbnames that may be used as
input to this function.

id is an (alpha)numeric identifier for some record in the database specified by dbname.

field may be optionally specified.  This will restrict database cross-references returned to those that are found in a certain field of
the source record.  Use the helper function SHoundDxFieldNameListFromDbName to retrieve a list of field names that may be used as input
to this function.

cv may be optionally specified.  This will restrict database cross-references returned to those that are labelled with the specified
controlled vocabulary term (cv).  cv is an integer that describes the relationaship of the cross-reference to the source record.  See the
 SeqHound Manual (section 5) for more details on cv.  You may also use the helper function SHoundGetDxCvTermList to retrieve a list of cv
 values (and their meanings) that may be used as input to this function.<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundDxListFromSource>list of functions</a><br><br>

<br><h2><a name=SHoundGetDxCvTermList>SHoundGetDxCvTermList</a></h2>

<br><b>description: </b>This helper function will retrieve a set of controlled vocabulary terms that may be used with the DBXref
functions.<br>
<b>comment: </b>There are no input parameters.  The returned structure consists of a list of pairs of cv identifiers and a description of
 the cv term.<br>
<br><br><b>Java</b><br>


<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundGetDxCvTermList>list of functions</a><br><br>

<br><h2><a name=SHoundGetDxDbNames>SHoundGetDxDbNames</a></h2>

<br><b>description: </b>This helper function retrieves a list of dbnames that may be consumed (or returned) by DBXref API functions.<br>

<b>comment: </b>The user may specify that they only want dbnames used to describe source records (set source_dbnames to 1 and dxdbnames
to 0) or that they only want those names used to describe the database cross-references (use the inverse settings).  By default, all
dbnames will be returned, both input booleans set to 1).<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundGetDxDbNames>list of functions</a><br><br>

<br><h2><a name=SHoundSourceListFromDx>SHoundSourceListFromDx</a></h2>
<br><b>description: </b>This is the reciprocal function to SHoundDxListFromSource.  Given a database name and identifier for some
database cross-reference, this function retrieves a list of source records where the cross-reference is cited.<br>


<b>comment: </b>dbname is a database name.  Use the helper function SHoundGetDxDbnames to retrieve a list of dbnames that may be used as
input to this function.

id is an (alpha)numeric identifier for some record in the database specified by dbname.

The returned structure is a ShDxList of ShDx.  The value of field will indicate where the source record identifier is found and cv will
always be zero.

Field may be optionally specified.  Returned source records cite the given database cross-reference in the specified field.  Use the
helper function SHoundDxFieldNameListFromDbName to retrieve a list of field names that may be used as input to this function.

cv may be optionally specified.  This will restrict  returned source records to those that cite the given cross-reference using the
specified controlled vocabulary term (cv).  cv is an integer that describes the relationaship of the cross-reference to the source
record.  See the SeqHound Manual (section 5) for more details on cv.  You may also use the helper function SHoundGetDxCvTermList to
retrieve a list of cv values (and their meanings) that may be used as input to this function.<br>

<br><br><b>Java</b><br>
<b>comment: </b>See the <a href="http://www.blueprint.org/seqhound/javadocs/org/blueprint/seqhound/interfaces/SHoundDbxrefInterface.html">JavaDocs</a>
for the SHoundDbxrefInterface.<br>

<a href=apifunctslist.html#SHoundSourceListFromDx>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_9>SEQUENCE AND STRUCTURE CHECKS</a></h1><br><br>These functions may be used to do things like tell whether a given GenInfo
identifier (GI) refers to a protein sequence record or whether it exists in the SeqHound database.<br><br>





<br><h2><a name=SHound3DbWhat>SHound3DbWhat</a></h2>
<br><b>description: </b>Finds out what kind of molecules are contained in a 3-D structure.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer MMDB identifier<br>

<b>return: </b>integer which represents different kinds of molecules,
<br>The return values are so called "byte flags" where each bit is reserved for one kind of molecule:
<br>#define  AM_ION   0x80  //ion
<br>#define  AM_RNA   0x40  //RNA
<br>#define  AM_WAT   0x20  //water
<br>#define  AM_SOL   0x10  //solvent
<br>#define  AM_HET   0x08  //heteroatom
<br>#define  AM_DNA   0x04  //DNA
<br>#define  AM_PROT  0x02  //protein
<br>#define  AM_POLY  0x01  //polymer
<br>
<br> -1 if not found or zero<br>
<b>prototype: </b>Int4 SHound3DbWhat(Int4 mmdbid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer MMDB identifier<br>

<b>return: </b>integer which represents different kinds of molecules
<br>The return values are so called "byte flags" where each bit is reserved for one kind of molecule:
<br>#define  AM_ION   0x80  // ion
<br>#define  AM_RNA   0x40  //RNA
<br>#define  AM_WAT   0x20  //water
<br>#define  AM_SOL   0x10  //solvent
<br>#define  AM_HET   0x08  //heteroatom
<br>#define  AM_DNA   0x04  //DNA
<br>#define  AM_PROT  0x02  //protein
<br>#define  AM_POLY  0x01  //polymer
<br>
<br>or an error code:
<br>SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred.
<b>prototype: </b>int SHound3DbWhat(int mmdbid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>an integer which represents different kinds of molecules or zero<br>

<b>example: </b>SHound3DbWhat(3436);<br>
<a href=apifunctslist.html#SHound3DbWhat>list of functions</a><br><br>

<br><h2><a name=SHound3DExists>SHound3DExists</a></h2>
<br><b>description: </b>Finds out whether a given structural identifier (MMDB ID) exists in the system.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>TRUE if exists, FALSE if it does not<br>
<b>prototype: </b>Boolean SHound3DExists(Int4 mmdbid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>TRUE if it exists, FALSE if it does not<br>

<b>prototype: </b>bool SHound3DExists(int mmdbid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>identifier from Molecular Modeling Database (MMDB ID) (e.g. 11)<br>

<b>return: </b>"TRUE" if exists, "FALSE" if it does not<br>
<b>example: </b>SHound3DExists(4534);<br>
<a href=apifunctslist.html#SHound3DExists>list of functions</a><br><br>


<br><h2><a name=SHoundExists>SHoundExists</a></h2>

<br><b>description: </b>Reports whether a given GI identifier exists in the SeqHound system.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>TRUE if exists, FALSE if it does not<br>
<b>prototype: </b>Boolean SHoundExists(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>true if it exists, false if it does not<br>
<b>prototype: </b>bool SHoundExists(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>
<b>return: </b>"TRUE" if exists, "FALSE" if it does not<br>

<b>example: </b>SHoundExists(34543);<br>
<a href=apifunctslist.html#SHoundExists>list of functions</a><br><br>

<br><h2><a name=SHoundGetLargestMMDBID>SHoundGetLargestMMDBID</a></h2>
<br><b>description: </b>Gets the largest Molecular Modeling Database identifier (MMDBID) in the current MMDB database<br>



<br><br><b>C</b><br>
<b>arguments: </b>void<br>
<b>return: </b>an integer largest MMDB ID or zero if error or -1 if not found<br>

<b>prototype: </b>Int4  SHoundGetLargestMMDBID(void)<br>
<br><br><b>C++</b><br>
<b>arguments: </b>void<br>

<b>return: </b>an integer largest MMDB ID or SEQHOUND_ERROR, SEQHOUND_NULL, WWWGETFILE_ERROR, SEQHOUND_ABNORMAL<br>
<b>prototype: </b>int SHoundGetLargestMMDBID(void)<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>null<br>
<b>return: </b>an integer largest MMDB ID or zero if failure<br>
<b>example: </b>$a = SHoundGetLargestMMDBID();<br>

<a href=apifunctslist.html#SHoundGetLargestMMDBID>list of functions</a><br><br>
<br><h2><a name=SHoundIsNRFirst>SHoundIsNRFirst</a></h2>

<br><b>description: </b>Reports if a given GI identifier represents the best annotated version from a group of database entries
referring to the same protein sequence (so called redundant proteins).<br>
<b>comment: </b>Usable only for proteins, DNA will always return "FALSE"; generally the PDB, RefSeq and Swiss-Prot annotations are
considered the most complete<br>
<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundIsNRFirst(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>true if success or false<br>
<b>prototype: </b>bool SHoundIsNRFirst(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier (e.g. 3236312)<br>

<b>return: </b>"TRUE" if success, "FALSE"<br>
<b>example: </b>SHoundIsNRFirst(34543);<br>
<a href=apifunctslist.html#SHoundIsNRFirst>list of functions</a><br><br>

<br><h2><a name=SHoundIsProtein>SHoundIsProtein</a></h2>

<br><b>description: </b>Reports whether a given GI identifier denotes a protein (as opposed to DNA or RNA).<br>

<b>comment: </b>This function will be deprecated.  Please use  SHoundMoleculeType<br>
<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>TRUE if it is protein, FALSE if it is not<br>
<b>prototype: </b>Boolean SHoundIsProtein(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>true if it is protein, false if it is not<br>
<b>prototype: </b>bool SHoundIsProtein(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>
<b>return: </b>"TRUE" if it is protein, "FALSE" if it is not<br>

<b>example: </b>SHoundIsProtein(354);<br>
<a href=apifunctslist.html#SHoundIsProtein>list of functions</a><br><br>

<br><h2><a name=SHoundMoleculeType>SHoundMoleculeType</a></h2>
<br><b>description: </b>Gets molecule type for a given GI identifier<br>

<b>comment: </b>This function deprecates SHoundIsProtein<br>
<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>protein if given gi is the type of a protein
<br>dna if given gi is the type of a dna
<br>rna if given gi is the type of a rna
<br>else returns NULL<br>
<b>prototype: </b>CharPtr SHoundMoleculeType (Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>protein, dna, rna or NULL<br>
<b>return: </b>protein, dna, rna or an empty string<br>

<b>prototype: </b>string SHoundMoleculeType(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI (e.g. 6322016)<br>

<b>return: </b>molecule type (dna, rna, protein) or zero if failure<br>
<b>example: </b>SHoundMoleculeType(6322016)<br>
<a href=apifunctslist.html#SHoundMoleculeType>list of functions</a><br><br>

<br><h2><a name=SHoundSequenceLength>SHoundSequenceLength</a></h2>

<br><b>description: </b>Gets sequence length from GI identifier<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>integer sequence length or  -1 on error or not found or 0 on error<br>
<b>prototype: </b>Int4 SHoundSequenceLength(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer length or SEQHOUND_ERROR, SEQHOUND_NULL, WWWGETFILE_ERROR, SEQHOUND_ABNORMAL<br>
<b>prototype: </b>int SHoundSequenceLength(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI (e.g. 21071030)<br>
<b>return: </b>sequence length or zero if failure<br>

<b>example: </b>SHoundSequenceLength(21071030);<br>
<a href=apifunctslist.html#SHoundSequenceLength>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_11>SEQUENCE FETCH ASN.1 BIOSEQ</a></h1><br><br>These functions return a sequence record as a "Bioseq".  A "Bioseq" is an NCBI
 data structure used to store sequence data.  To see a complete description of a Bioseq in ASN.1 format, go to
http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SB/hbr.html , type in the query "Bioseq" check the box beside "asns" and hit the "Submit query button".<br><br>






<br><h2><a name=SHoundGetBioseq>SHoundGetBioseq</a></h2>

<br><b>description: </b>Fetches ASN.1 representation of a sequence called Bioseq. The Bioseq is a structure used to represent a single
sequence, it contains all available annotation.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to ASN.1 Bioseq in a binary format or NULL<br>
<b>prototype: </b>BioseqPtr SHoundGetBioseq(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to ASN.1 Bioseq in a binary format or NULL<br>

<b>prototype: </b>CBioseq *SHoundGetBioseq(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>

<b>return: </b>ASN.1 Bioseq in a parseable text format or zero<br>
<b>example: </b>SHoundGetBioseq(535);<br>
<a href=apifunctslist.html#SHoundGetBioseq>list of functions</a><br><br>

<br><h2><a name=SHoundGetBioseqList>SHoundGetBioseqList</a></h2>

<br><b>description: </b>Fetches a list of ASN.1 Bioseqs. The Bioseq is a structure used to represent a single sequence, it contains all
available annotation.<br>
<b>comment: </b>The order in the lists is not maintained.<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>

<b>return: </b>pointer to a ValNode linked list of ASN.1 Bioseqs in a binary format or  NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetBioseqList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of ASN.1 Bioseqs in a binary format or  NULL<br>

<b>prototype: </b>CSLRIValNode *SHoundGetBioseqList(list<int>& sltGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of GI identifiers<br>

<b>return: </b>list of ASN.1 Bioseqs in a text format or zero<br>
<b>example: </b>SHoundGetBioseqList("332");<br>
<a href=apifunctslist.html#SHoundGetBioseqList>list of functions</a><br><br>

<br><h2><a name=SHoundGetXMLBioseq>SHoundGetXMLBioseq</a></h2>

<br><b>description: </b>Fetches XML representation of a Bioseq. The Bioseq is a structure used to represent a single sequence, it
contains  all available annotation.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier and pointer to a string containing output file  name<br>
<b>return: </b>TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundGetXMLBioseq(Int4 gi, CharPtr file_name);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier and string output file name<br>
<b>return: </b>true if success or false<br>
<b>prototype: </b>bool SHoundGetXMLBioseq(int Gi, string file_name);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>integer GI identifier (e.g. 4646)<br>
<b>return: </b>XML sequence record or zero<br>

<b>example: </b>SHoundGetXMLBioseq(555);<br>
<a href=apifunctslist.html#SHoundGetXMLBioseq>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_12>SEQUENCE FETCH ASN.1 BIOSEQSET</a></h1><br><br>These functions return a set of sequence records as a bioseqset (also see
functions under "SEQUENCE FETCH  ASN.1 BIOSEQ").<br><br>



<br><h2><a name=SHoundGetBioseqSet>SHoundGetBioseqSet</a></h2>
<br><b>description: </b>Fetches ASN.1 representation of a sequence called BioseqSet. BioseqSet exists only if there is more than one
sequence in logical group of sequences (e.g. gene and its protein product).<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to ASN.1 BioseqSet in a binary format or NULL<br>
<b>prototype: </b>BioseqSetPtr SHoundGetBioseqSet(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to ASN.1 BioseqSet in a binary format or NULL<br>
<b>prototype: </b>CBioseq_set *SHoundGetBioseqSet(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier<br>
<b>return: </b>ASN.1 BioseqSet in a text format or zero<br>
<b>example: </b>SHoundGetBioseqSet(666);<br>

<a href=apifunctslist.html#SHoundGetBioseqSet>list of functions</a><br><br>
<br><h2><a name=SHoundGetBioseqSetList>SHoundGetBioseqSetList</a></h2>

<br><b>description: </b>Fetches a list of ASN.1 BioseqSets. BioseqSet exists only if there is more than one sequence in logical group of
 sequences (e.g. gene and its protein product).<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of ASN.1 BioseqSets in a binary format  or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetBioseqSetList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to a ValNode linked list of ASN.1 BioseqSets in a binary format  or NULL<br>
<b>prototype: </b>CSLRIValNode *SHoundGetSeqEntryList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited  list of GI identifiers<br>
<b>return: </b>list of ASN.1 BioseqSets in a test format of zero<br>
<b>example: </b>SHoundGetBioseqSetList("666,555");<br>
<a href=apifunctslist.html#SHoundGetBioseqSetList>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_13>SEQUENCE FETCH ASN.1 SEQENTRY</a></h1><br><br>A Seq-entry is an NCBI data structure used to hold Bioseqs and Bioseq-sets
(see above).  To see a complete description of a bioseq in ASN.1 format, go to http://www.ncbi.nlm.nih.gov/IEB/ToolBox/SB/hbr.html, type in the query
"Seq-entry", check the box beside "asns" and hit the "Submit query button".<br><br>





<br><h2><a name=SHoundGetSeqEntry>SHoundGetSeqEntry</a></h2>

<br><b>description: </b>Fetches ASN.1 representation of a sequence called SeqEntry. SeqEntry contains a single sequence or a group of
sequences if they are logically related (e.g. gene and its protein product).<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to ASN.1 SeqEntry in a binary format or NULL<br>
<b>prototype: </b>SeqEntryPtr SHoundGetSeqEntry(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to ASN.1 SeqEntry in a binary format or NULL<br>

<b>prototype: </b>CSeq_entry *SHoundGetSeqEntry(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>

<b>return: </b>ASN.1 SeqEntry in a text format or zero<br>
<b>example: </b>SHoundGetSeqEntry(234);<br>
<a href=apifunctslist.html#SHoundGetSeqEntry>list of functions</a><br><br>

<br><h2><a name=SHoundGetSeqEntryList>SHoundGetSeqEntryList</a></h2>

<br><b>description: </b>Fetches a list of ASN.1 SeqEntries. SeqEntry contains a single sequence or a group of sequences if they are
logically related (e.g. gene and its protein product).<br>
<b>comment: </b>The order in the lists is not maintained.<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of ASN.1 SeqEntries in a binary format  or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetSeqEntryList(ValNodePtr pvnGi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of ASN.1 SeqEntries in a binary format  or NULL<br>

<b>prototype: </b>CSLRIValNode *SHoundGetSeqEntryList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers<br>

<b>return: </b>list of ASN.1 SeqEntries in a text format or zero<br>
<b>example: </b>SHoundGetSeqEntryList("342,555");<br>
<a href=apifunctslist.html#SHoundGetSeqEntryList>list of functions</a><br><br>

<br><h2><a name=SHoundGetXMLSeqEntry>SHoundGetXMLSeqEntry</a></h2>

<br><b>description: </b>Fetches XML representation of SeqEntry. SeqEntry contains a single sequence or a group of sequences if they are
logically related (e.g. gene and its protein product).<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier and pointer to a string containing output file  name<br>

<b>return: </b>TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundGetXMLSeqEntry(Int4 gi, CharPtr file_name)<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier and string output file name<br>
<b>return: </b>true if success or false<br>
<b>prototype: </b>bool SHoundGetXMLSeqEntry(int Gi, string file_name);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier (e.g. 4646)<br>
<b>return: </b>XML object or zero<br>

<b>example: </b>SHoundGetXMLSeqEntry(555);<br>
<a href=apifunctslist.html#SHoundGetXMLSeqEntry>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_14>SEQUENCE FETCH FASTA</a></h1><br><br>These functions return a sequence record(s) in FASTA format given a GenBank GenInfo
identifier (GI).<br><br>



<br><h2><a name=SHoundGetFasta>SHoundGetFasta</a></h2>
<br><b>description: </b>Fetches FASTA formatted sequence.  The FASTA format is widely used in the bioinformatics community; it consists
of a definition line, new line followed by a sequence terminated by a second new line.<br>



<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to SLRIFasta structure or NULL<br>

<b>prototype: </b>SLRIFastaPtr SHoundGetFasta(Int4 Gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to SLRIFasta structure or NULL<br>
<b>prototype: </b>CSLRIFasta *SHoundGetFasta(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier<br>
<b>return: </b>FASTA formatted sequence or zero<br>

<b>example: </b>SHoundGetFasta(666);<br>
<a href=apifunctslist.html#SHoundGetFasta>list of functions</a><br><br>

<br><h2><a name=SHoundGetFastaFromRedundantGroupID>SHoundGetFastaFromRedundantGroupID</a></h2>
<br><b>description: </b>Fetches FASTA formatted sequence for given redundant group identifier.  The FASTA format is widely used in the
bioinformatics community; it consists of a definition line, new line followed by a sequence terminated by a second new line.  Entrez
collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.   The redundant group
 identifiers can only be used temporarily, they change every day.<br>



<br><br><b>PERL</b><br>
<b>arguments: </b>redundant group id<br>
<b>return: </b> FASTA sequence or zero if failure<br>

<b>example: </b>SHoundGetFastaFromRedundantGroupID(123);<br>
<a href=apifunctslist.html#SHoundGetFastaFromRedundantGroupID>list of functions</a><br><br>

<br><h2><a name=SHoundGetFastaFromRedundantGroupIDKeyedList>SHoundGetFastaFromRedundantGroupIDKeyedList</a></h2>

<br><b>description: </b>Fetches FASTA formatted sequence for given redundant group identifiers.  The FASTA format is widely used in
bioinformatics community; it consists of a definition line, new line followed by a sequence terminated by a second new line.  Entrez
collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.   The redundant group
 identifiers can only be used temporarily, they change every day.<br>


<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of redundant group ids<br>
<b>return: </b>hash table, each entry of the table stores FASTA structure and its associated query redundant group id
<br>or an empty hash table if failure<br>
<b>example: </b>%hash = SHoundGetFastaFromRedundantGroupIDKeyedList("362477,123,111");<br>
<a href=apifunctslist.html#SHoundGetFastaFromRedundantGroupIDKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundGetFastaKeyedList>SHoundGetFastaKeyedList</a></h2>

<br><b>description: </b>Fetches GI identifiers and associated FASTA formatted sequences. The FASTA format is widely used in
bioinformatics community; it consists of a definition line, new line followed by a sequence terminated by a second new line.<br>


<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of GI identifiers<br>

<b>return: </b>hash table, each entry of the table stores a fasta stucture and its associated  query gi
<br>or an empty hash table if failure<br>
<b>example: </b>%hash = SHoundGetFastaKeyedList("555,111,4557225");<br>
<a href=apifunctslist.html#SHoundGetFastaKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundGetFastaList>SHoundGetFastaList</a></h2>

<br><b>description: </b>Fetches a list of FASTA formatted sequences. The FASTA format is widely used in bioinformatics community; it
consists of a definition line, new line followed by a sequence terminated by a second new line.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>

<b>return: </b>pointer to a ValNode linked list of SLRIFasta structures or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetFastaList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of SLRIFasta structures or NULL<br>
<b>prototype: </b>CSLRIValNode *SHoundGetFastaList(list<int>& stlGi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers<br>
<b>return: </b>FASTA formatted sequences or zero.<br>

<b>example: </b>SHoundGetFastaList("666,555");<br>
<a href=apifunctslist.html#SHoundGetFastaList>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_3>DEFLINE FETCH</a></h1><br><br>These functions return a definition line for a sequence record(s) given a GenBank GenInfo
identifier (GI).<br><br>



<br><h2><a name=SHoundGetDefline>SHoundGetDefline</a></h2>
<br><b>description: </b>Fetches definition line for a sequence.  A definition line contains the GI, accession number and other available
 identifiers together with a short description of the sequence.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to a string containing definition line or NULL on error<br>
<b>prototype: </b>CharPtr SHoundGetDefline(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>string containing definition line or an empty string<br>
<b>prototype: </b>string SHoundGetDefline(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier<br>
<b>return: </b>string containing definition line or zero<br>
<b>example: </b>SHoundGetDefline(4646);<br>

<a href=apifunctslist.html#SHoundGetDefline>list of functions</a><br><br>
<br><h2><a name=SHoundGetDeflineList>SHoundGetDeflineList</a></h2>

<br><b>description: </b>Fetches multiple definition lines for a list of sequences. A definition line contains the GI, accession number
and other available identifiers together with a short description of the sequence.<br>

<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list containing string definition lines or  NULL<br>
<b>prototype: </b>CharPtr SHoundGetDeflineList(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to an STL list of strings containing lines or to an empty list<br>

<b>prototype: </b>list<string> *SHoundGetDeflineList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  linked list of GI identifiers<br>

<b>return: </b>comma delimited  list containing definition lines or zero<br>
<b>example: </b>SHoundGetDeflineList("2645003,480117,230940");<br>

<a href=apifunctslist.html#SHoundGetDeflineList>list of functions</a><br><br>
<br><br><h1><a name=SECTIONID_15>SEQUENCE FETCH GENBANK FLAT FILE</a></h1><br><br>These functions return a sequence record(s) in GenBank flat file format
given a GenBank GenInfo identifier (GI).<br><br>




<br><h2><a name=SHoundGetGenBankff>SHoundGetGenBankff</a></h2>
<br><b>description: </b>Fetches GenBank formatted sequence.  GenBank flat file contains comprehensive full annotation of a sequence.<br>



<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier and an output file pointer<br>
<b>return: </b>TRUE if success or FALSE<br>

<b>prototype: </b>Boolean SHoundGetGenBankff(Int4 gi, FILE *pfile);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier and a pointer to an output stream<br>

<b>return: </b>true if success or false<br>
<b>prototype: </b>bool SHoundGetGenBankff(int Gi, ofstream& pfile);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier<br>
<b>return: </b>GenBank formatted sequence or zero<br>
<b>example: </b>SHoundGetGenBankff(32);<br>

<a href=apifunctslist.html#SHoundGetGenBankff>list of functions</a><br><br>
<br><h2><a name=SHoundGetGenBankffList>SHoundGetGenBankffList</a></h2>

<br><b>description: </b>Fetches a list of GenBank formatted sequences. GenBank flat file contains comprehensive full annotation of a
sequence.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers and an  output file pointer<br>
<b>return: </b>TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundGetGenBankffList(ValNodePtr pvnGi, FILE *pfile);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers and a pointer to an output stream<br>
<b>return: </b>true if success or false<br>

<b>prototype: </b>bool SHoundGetGenBankffList(list<int>& stlGi, ofstream& pfile);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers or zero<br>

<b>return: </b>GenBank formatted sequences<br>
<b>example: </b>SHoundGetGenBankffList("32,666");<br>
<a href=apifunctslist.html#SHoundGetGenBankffList>list of functions</a><br><br>

<br><h2><a name=SHoundGetSeqFromGenBank>SHoundGetSeqFromGenBank</a></h2>
<br><b>description: </b>Fetches a GenBank sequence.<br>





<a href=apifunctslist.html#SHoundGetSeqFromGenBank>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_21>STRUCTURE FETCH</a></h1><br><br>These functions return a biological structure record in either the Molecular Modeling
Database (MMDB) format or the Protein Database (PDB) format.<br><br>



<br><h2><a name=SHoundGet3D>SHoundGet3D</a></h2>

<br><b>description: </b>Fetches ASN.1 representation of a 3-D structure called Biostruc.  Biostrucs represent data model in the
Molecular Modeling database.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>
<b>prototype: </b>BiostrucPtr SHoundGet3D(Int4 mmdbid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>

<b>prototype: </b>CBiostruc *SHoundGet3D(int mmdbid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>identifier from Molecular Modeling Database (MMDB ID)<br>

<b>return: </b>ASN.1 Biostruc in a parseable text format or zero<br>
<b>example: </b>SHoundGet3D(32);<br>
<a href=apifunctslist.html#SHoundGet3D>list of functions</a><br><br>

<br><h2><a name=SHoundGet3DEx>SHoundGet3DEx</a></h2>

<br><b>description: </b>Fetches ASN.1 representation of a 3-D structure called Biostruc.  Biostrucs represent data model in the
Molecular Modeling database.  The same as SHoundGet3D but with additional options of model level and max models.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier, integer model level and integer maximum models<br>

<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>
<b>prototype: </b>BiostrucPtr  SHoundGet3DEx(Int4 Gi,Int4 mdlLvl,Int4 maxModels)<br>
<a href=apifunctslist.html#SHoundGet3DEx>list of functions</a><br><br>

<br><h2><a name=SHoundGet3DfromPdbId>SHoundGet3DfromPdbId</a></h2>

<br><b>description: </b>Fetches ASN.1 representation of a 3-D structure called Biostruc. Biostrucs represent data model in the Molecular
 Modeling database.<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing PDB code from Protein Databank<br>

<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>
<b>prototype: </b>BiostrucPtr SHoundGet3DfromPdbId(CharPtr pdbid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>string PDB code from Protein Databank<br>
<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>
<b>prototype: </b>CBiostruc *SHoundGet3DfromPdbId(string pdbid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>PDB code (e.g. 3TS1)<br>
<b>return: </b>ASN.1 Biostruc in a parseable text format or zero<br>

<b>example: </b>SHoundGet3DfromPdbId("3INS");<br>
<a href=apifunctslist.html#SHoundGet3DfromPdbId>list of functions</a><br><br>

<br><h2><a name=SHoundGet3DfromPdbIdEx>SHoundGet3DfromPdbIdEx</a></h2>
<br><b>description: </b>Fetches ASN.1 representation of a 3-D structure called Biostruc. Biostrucs represent data model in the Molecular
 Modeling database.  The same as SHoundGet3DfromPdbId but with additional options of model level and max models.<br>



<br><br><b>C</b><br>
<b>arguments: </b>integer PDB identifier, integer model level and integer maximum models<br>
<b>return: </b>pointer to ASN.1 Biostruc in a binary format or NULL<br>

<b>prototype: </b>BiostrucPtr  SHoundGet3DfromPdbIdEx(CharPtr pdbid,Int4 mdlLvl,Int4 maxModels)<br>
<a href=apifunctslist.html#SHoundGet3DfromPdbIdEx>list of functions</a><br><br>

<br><h2><a name=SHoundGetPDB3D>SHoundGetPDB3D</a></h2>
<br><b>description: </b>Fetches a 3-D structure in Protein Data Bank (PDB) format.  PDB text format is a format used by Protein Data
Bank.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer MMDB identifier and pointer to a string containing output<br>

<b>return: </b>TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundGetPDB3D(Int4 mmdbid, CharPtr file_name);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer MMDB identifier and a reference to output file name<br>
<b>return: </b>true if success or false<br>
<b>prototype: </b>bool SHoundGetPDB3D(int mmdbid, string& file);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>identifier from Molecular Modeling Database (MMDB ID)<br>
<b>return: </b>PDB formatted structural record or zero<br>
<b>example: </b>SHoundGetPDB3D(11);<br>

<a href=apifunctslist.html#SHoundGetPDB3D>list of functions</a><br><br>
<br><h2><a name=SHoundGetXML3D>SHoundGetXML3D</a></h2>

<br><b>description: </b>Fetches XML representation of a 3-D structure.  XML is a converted Biostruc which represent data model in
Molecular Modeling database.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer MMDB identifier and pointer to a string containing an output  file name<br>
<b>return: </b>TRUE if success or FALSE<br>

<b>prototype: </b>Boolean SHoundGetXML3D(Int4 mmdbid, CharPtr file_name);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer MMDB identifier and an output file name<br>
<b>return: </b>true if success or false<br>

<b>prototype: </b>bool SHoundGetXML3D(int mmdbid, string file);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>identifier from Molecular Modeling Database (MMDB ID)<br>

<b>return: </b>XML structural record or zero<br>
<b>example: </b>SHoundGetXML3D(11);<br>
<a href=apifunctslist.html#SHoundGetXML3D>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_8>SEQHOUND LINKS</a></h1><br><br>These functions return links to other databases found in a sequence or structure record.
For instance, given the GI of a protein sequence record, you can retrieve links to the nucleic acid record that encodes that protein or the organism that
the protein belongs to.<br><br>





<br><h2><a name=SHound3DFromGi>SHound3DFromGi</a></h2>

<br><b>description: </b>Converts a GI sequence identifier to a structural MMDB identifier. Reports in which 3-D structure a particular
sequence can be found.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer MMDB identifier, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHound3DFromGi(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer MMDB identifier or an error code:
<br>SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred
<br>SEQHOUND_NULL if the value was not found in the database
<br>WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHound3DFromGi(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI sequence identifier<br>
<b>return: </b>MMDB identifier or zero<br>

<b>example: </b>SHound3DFromGi(442560);<br>
<a href=apifunctslist.html#SHound3DFromGi>list of functions</a><br><br>

<br><h2><a name=SHound3DFromGiList>SHound3DFromGiList</a></h2>
<br><b>description: </b>Converts a list of sequence GI identifiers to a list of structural MMDB identifiers.<br>

<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer MMDB identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHound3DFromGiList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to an STL list of integer MMDB identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHound3DFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of GI identifiers<br>
<b>return: </b>comma delimited  list of MMDB identifiers or zero<br>
<b>example: </b>SHound3DFromGiList("442560,442572");<br>

<a href=apifunctslist.html#SHound3DFromGiList>list of functions</a><br><br>


<br><h2><a name=SHoundDNAFromProtein>SHoundDNAFromProtein</a></h2>

<br><b>description: </b>Converts protein (gene product)  identifier to a nucleic acid (gene) identifier.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier to a protein<br>

<b>return: </b>integer GI identifier to nucleic acid, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHoundDNAFromProtein(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier to a protein<br>
<b>return: </b>integer GI identifier to nucleic acid or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the
value was not found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundDNAFromProtein(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>protein GI identifier<br>
<b>return: </b>DNA GI identifier or zero<br>
<b>example: </b>SHoundDNAFromProtein(32);<br>

<a href=apifunctslist.html#SHoundDNAFromProtein>list of functions</a><br><br>
<br><h2><a name=SHoundDNAFromProteinList>SHoundDNAFromProteinList</a></h2>

<br><b>description: </b>Converts a list of protein (gene product) identifiers to a list of nucleic acids (genes) identifiers.<br>

<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list or integer GI identifiers referring to proteins<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers referring to nucleic acids or NULL<br>

<b>prototype: </b>ValNodePtr SHoundDNAFromProteinList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers referring to proteins<br>

<b>return: </b>pointer to an STL list of integer GI identifiers referring to nucleic acids or pointer to an empty list<br>
<b>prototype: </b>list<int> *SHoundDNAFromProteinList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of protein identifiers<br>

<b>return: </b>comma delimited list of DNA identifiers or zero<br>
<b>example: </b>SHoundDNAFromProteinList("325,4546");<br>
<a href=apifunctslist.html#SHoundDNAFromProteinList>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromTaxID>SHoundDNAFromTaxID</a></h2>

<br><b>description: </b>Gets all nucleic acid sequence identifiers from one organism.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundDNAFromTaxID(Int4 taxid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundDNAFromTaxID(int taxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>

<b>return: </b>comma delimited list of GI identifiers or zero<br>
<b>example: </b>SHoundDNAFromTaxID(10665);<br>
<a href=apifunctslist.html#SHoundDNAFromTaxID>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromTaxIDIII>SHoundDNAFromTaxIDIII</a></h2>

<br><b>description: </b>Gets all nucleic acid sequence identifiers from one organism.  The function takes advantage of precomputed
searches if the appropriate one is available.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromTaxIDIII(Int4 taxid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundDNAFromTaxIDIII(int taxid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>comma delimited list of GI identifiers or zero<br>

<b>example: </b>SHoundDNAFromTaxIDIII(10665);<br>
<a href=apifunctslist.html#SHoundDNAFromTaxIDIII>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromTaxIDList>SHoundDNAFromTaxIDList</a></h2>
<br><b>description: </b>Gets all nucleic acid sequence identifiers from a list of organisms.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>ValNode linked list of integer taxonomy identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromTaxIDList(ValNodePtr pvntaxid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer taxonomy identifiers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundDNAFromTaxIDList(list<int>& stltaxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of taxonomy identifiers<br>

<b>return: </b>comma delimited list of nucleic acid GI identifiers or zero<br>
<b>example: </b>SHoundDNAFromTaxIDList(10665);<br>
<a href=apifunctslist.html#SHoundDNAFromTaxIDList>list of functions</a><br><br>

<br><h2><a name=SHoundGetReferenceIDFromGi>SHoundGetReferenceIDFromGi</a></h2>

<br><b>description: </b>Retrieves publication reference ID from a GI and reference type.<br>
<b>comment: </b>Currently PubMed ID is not available.

This function deprecates SHoundMuidFromGi<br>
<br><br><b>C</b><br>


<b>arguments: </b>integer GI identifier
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b> valnodeptr linked with a list of reference id (pubmedid, medlineids) or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGetReferenceIDFromGi(Int4 Gi, Int2 referencetype);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>list of integer reference ids or NULL<br>
<b>prototype: </b>list<int> *SHoundGetReferenceIDFromGi(int Gi, int reftype);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI (e.g. 6322016)
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>a list of comma delimited reference ID or zero if failure<br>
<b>example: </b>SHoundGetReferenceIDFormGi(6322016,  2)<br>

<a href=apifunctslist.html#SHoundGetReferenceIDFromGi>list of functions</a><br><br>
<br><h2><a name=SHoundGetReferenceIDFromGiList>SHoundGetReferenceIDFromGiList</a></h2>

<br><b>description: </b>Retrieves publication reference ID from a GI list and reference type.<br>

<b>comment: </b>This function deprecates SHoundMuidFromGiList<br>

<b>check: </b>duplicates in list?<br>

<br><br><b>C</b><br>
<b>arguments: </b>GI list
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>valnodeptr linked with a list of reference ids (unique) or NULL<br>
<b>prototype: </b>ValNodePtr   SHoundGetReferenceIDFromGiList(ValNodePtr vnpgi, Int2 referencetype);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>GI list
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>list of integer reference ids (unique) or NULL<br>
<b>prototype: </b>list<int> *SHoundGetReferenceIDFromGiList(list<int>& stlGi, int reftype);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI list (e.g. 6322016,4557225,21071030)
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>a list of comma delimited reference ID or zero if failure<br>
<b>example: </b>SHoundGetReferenceIDFormGilist(6322016,4557225,21071030,  2)<br>

<a href=apifunctslist.html#SHoundGetReferenceIDFromGiList>list of functions</a><br><br>




<br><h2><a name=SHoundGiFrom3D>SHoundGiFrom3D</a></h2>

<br><b>description: </b>Gets GI identifiers for sequence or sequences contained in a 3-D structure.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer MMDB identifier and a boolean variable indicating if user wants to get only protein GI identifiers<br>


<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or one GI or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFrom3D(Int4 mmdbid, Boolean ProteinOnly);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer MMDB identifier and a boolean variable indicating if user wants to get only protein GI identifiers<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFrom3D(int mmdbid, bool ProteinOnly);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>identifier from Molecular Modeling Database (MMDB ID) and a boolean variable indicating if user wants to get only protein GI
identifiers<br>
<b>return: </b>comma delimited  list of GI identifiers or one GI or zero<br>
<b>example: </b>SHoundGiFrom3D(23, "FALSE");<br>
<a href=apifunctslist.html#SHoundGiFrom3D>list of functions</a><br><br>

<br><h2><a name=SHoundGiFrom3DList>SHoundGiFrom3DList</a></h2>

<br><b>description: </b>Gets GI identifiers contained in a list of 3-D identifiers.<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of MMDB identifiers and a boolean variable indicating if user wants to get only protein GI
identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGiFrom3DList(ValNodePtr pvnMmdbid, Boolean ProteinOnly);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of MMDB identifiers and a boolean variable indicating if user wants to get only protein GI identifiers<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGiFrom3DList(list<int>& stlMmdbid, bool ProteinOnly);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of MMDB identifiers and a boolean variable indicating if user wants to get only protein GI identifiers<br>

<b>return: </b>comma delimited  list of GI identifiers or zero<br>

<b>example: </b>SHoundGiFrom3DList("23,32", "FALSE");<br>
<a href=apifunctslist.html#SHoundGiFrom3DList>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromPDBchain>SHoundGiFromPDBchain</a></h2>
<br><b>description: </b>Gets a GI  identifier for a Protein Data Bank (PDB) structural chain.  PDB code supplemented with a chain always
 refers to a single sequence.<br>


<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing PDB code; pointer to a string containing PDB chain (e.g. "A")<br>
<b>return: </b>integer GI identifier, -1 if not found or zero<br>

<b>prototype: </b>Int4 SHoundGiFromPDBchain(CharPtr pdbcode, CharPtr chain);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>string PDB code; string PDB chain (e.g. "A")<br>
<b>return: </b>integer GI identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not
found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundGiFromPDBchain(string pdbcode, string chain);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>PDB code; PDB chain (e.g. "A")<br>

<b>return: </b>GI identifier for the PDB chain or zero<br>
<b>example: </b>SHoundGiFromPDBchain("9XIM", "A");<br>
<a href=apifunctslist.html#SHoundGiFromPDBchain>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromReferenceID>SHoundGiFromReferenceID</a></h2>

<br><b>description: </b>Gets GI identifiers from publication reference ID.<br>
<b>comment: </b>Return value may be very long for some publications, eg for a high throughput publication.

Currently PubMed ID is not available.<br>
<br><br><b>C</b><br>

<b>comment: </b>The return list may contain duplicates.<br>
<b>arguments: </b>an integer referenceID
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>pointer to a list of integer GIs (not unique) or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGiFromReferenceID(Int4 referenceid, Int2 referencetype)<br>

<br><br><b>C++</b><br>
<b>comment: </b>The return list may contain duplicates.<br>
<b>arguments: </b>an integer referenceID
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>list of integer Gis or NULL<br>

<b>prototype: </b>list<int> *SHoundGiFromReferenceID(int refid, int reftype)<br>
<br><br><b>PERL</b><br>
<b>comment: </b>The return list may contain duplicates.<br>

<b>arguments: </b>reference ID (e.g. 85190481)
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b> a list of comma delimited GI or zero if failure<br>
<b>example: </b>SHoundGiFromReferenceID(85190481,  2)<br>
<a href=apifunctslist.html#SHoundGiFromReferenceID>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromReferenceList>SHoundGiFromReferenceList</a></h2>

<br><b>description: </b>Gets GI identifiers from publication reference ID list.<br>
<b>comment: </b>Return value may be very long for some publications, eg for a high throughput publication.

Currently PubMed ID is not available.<br>
<br><br><b>C</b><br>

<b>comment: </b>The return list may contain duplicates.<br>
<b>comment: </b>The return list may contain duplicates.<br>



<b>arguments: </b>a list of integer referenceIDs
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>valnodeptr linked with a list of integer GIs (unique) or NULL<br>
<b>prototype: </b>ValNodePtr   SHoundGiFromReferenceList(ValNodePtr vnpref, Int2 referencetype);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The return list is unique and sorted.<br>
<b>comment: </b>The return list is unique and sorted.<br>

<b>arguments: </b>a list of integer referenceIDs
<br>integer reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>list of integer Gis or NULL<br>
<b>prototype: </b>list<int> *SHoundGiFromReferenceList(list<int>& stlRef, int reftype);<br>
<br><br><b>PERL</b><br>

<b>comment: </b>The return gilist may contain duplicates<br>
<b>arguments: </b>referenceID list (e.g. 97002444, 85190481)
<br>reference type
<br>    1 for PubMed ID
<br>    2 for MedLine ID<br>
<b>return: </b>a list of comma delimited GI or zero if failure<br>
<b>example: </b>SHoundGiFromReferenceList(97002444,85190481,  2)<br>

<a href=apifunctslist.html#SHoundGiFromReferenceList>list of functions</a><br><br>
<br><h2><a name=SHoundMuidFrom3D>SHoundMuidFrom3D</a></h2>

<br><b>description: </b>Converts a Molecular Modeling Database structural identifier (MMDBID) to one or more MEDLINE identifiers (MUID).
 Fetches  identifier of the original paper discussing a given 3-D structure.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer MEDLINE identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundMuidFrom3D(Int4 mmdbid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>pointer to an STL list of integer MEDLINE identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundMuidFrom3D(int mmdbid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>MMDB identifier<br>

<b>return: </b>comma delimited list of MEDLINE identifiers or zero<br>
<b>example: </b>SHoundMuidFrom3D(11);<br>
<a href=apifunctslist.html#SHoundMuidFrom3D>list of functions</a><br><br>

<br><h2><a name=SHoundMuidFrom3DList>SHoundMuidFrom3DList</a></h2>

<br><b>description: </b>Converts a list of Molecular Modeling Database structural identifiers (MMDBID) to a list of MEDLINE identifiers
(MUID). Fetches identifiers of the original papers discussing given 3-D structures.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer MMDB identifiers<br>

<b>return: </b>pointer to a ValNode linked list of integer MEDLINE identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundMuidFrom3DList(ValNodePtr pvnMmdbid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer MMDB identifiers<br>
<b>return: </b>pointer to an STL list of integer MEDLINE identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundMuidFrom3DList(list<int>& stlmmdbid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of MMDB identifiers<br>
<b>return: </b>comma delimited  list of MEDLINE identifiers or zero<br>

<b>example: </b>SHoundMuidFrom3DList("11,12");<br>
<a href=apifunctslist.html#SHoundMuidFrom3DList>list of functions</a><br><br>

<br><h2><a name=SHoundMuidFromGi>SHoundMuidFromGi</a></h2>
<br><b>description: </b>Gets MEDLINE identifier(s) (MUID) for a given GI identifier.  Fetches identifier(s) of the original paper(s)
discussing a given sequence.<br>
<b>comment: </b>This function will be deprecated.  Please use SHoundGetReferenceIDFromGi<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer MEDLINE identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundMuidFromGi(Int4 Gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to an STL list of integer MEDLINE identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundMuidFromGi(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI sequence identifier<br>
<b>return: </b>comma delimited  list of MUID identifiers or zero<br>
<b>example: </b>SHoundMuidFromGi(32);<br>

<a href=apifunctslist.html#SHoundMuidFromGi>list of functions</a><br><br>
<br><h2><a name=SHoundMuidFromGiList>SHoundMuidFromGiList</a></h2>

<br><b>description: </b>Gets MEDLINE identifiers (MUID) for a list of GI identifiers. Fetches identifiers of  the original papers
discussing given sequences.<br>
<b>comment: </b>This function will be deprecated.  Please use SHoundGetReferenceIDFromGiList

The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of MUID identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundMuidFromGiList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to an STL list of integer MEDLINE identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundMuidFromGiList(list<int>& stlGi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers<br>
<b>return: </b>comma delimited  list of MUID identifiers or zero<br>

<b>example: </b>SHoundMuidFromGiList("324,32");<br>
<a href=apifunctslist.html#SHoundMuidFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundProteinFromDNA>SHoundProteinFromDNA</a></h2>

<br><b>description: </b>Converts a nucleic acid (gene) identifier to one or more  protein (gene product)  identifiers.<br>



<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier referring to nucleic acid<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers referring to proteins or NULL<br>

<b>prototype: </b>ValNodePtr SHoundProteinFromDNA(Int4 Gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier to nucleic acid<br>

<b>return: </b>pointer to an STL list of integer GI identifiers referring to proteins or pointer to an empty list<br>
<b>prototype: </b>list<int> *SHoundProteinFromDNA(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>DNA GI identifier<br>
<b>return: </b>comma delimited  list of protein identifiers<br>
<b>example: </b>SHoundProteinFromDNA(31);<br>
<a href=apifunctslist.html#SHoundProteinFromDNA>list of functions</a><br><br>

<br><h2><a name=SHoundProteinFromDNAList>SHoundProteinFromDNAList</a></h2>

<br><b>description: </b>Converts a list of nucleic acid (gene) identifiers to a list of protein (gene product) identifiers.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list or integer GI identifiers referring to nucleic acids<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers referring to proteins or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinFromDNAList(ValNodePtr pvnGi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers referring to nucleic acids<br>
<b>return: </b>pointer to an STL list of integer GI identifiers referring to proteins or pointer to an empty list<br>
<b>prototype: </b>list<int> *SHoundProteinFromDNAList(list<int>& stlGi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of DNA identifiers<br>
<b>return: </b>comma delimited  list of protein identifiers or zero<br>

<b>example: </b>SHoundProteinFromDNAList("324,4545");<br>
<a href=apifunctslist.html#SHoundProteinFromDNAList>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromTaxID>SHoundProteinsFromTaxID</a></h2>
<br><b>description: </b>Gets all protein GI identifiers from one organism.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinsFromTaxID(Int4 taxid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundProteinsFromTaxID(int taxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>

<b>return: </b>comma delimited  list of protein GI identifiers or zero<br>
<b>example: </b>SHoundProteinsFromTaxID(10665);<br>
<a href=apifunctslist.html#SHoundProteinsFromTaxID>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromTaxIDIII>SHoundProteinsFromTaxIDIII</a></h2>

<br><b>description: </b>Gets all protein GI identifiers from one organism. The function takes advantage of precomputed searches if the
appropriate one is available.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinsFromTaxIDIII(Int4 taxid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundProteinsFromTaxIDIII(int taxid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>comma delimited  list of protein GI identifiers or zero<br>

<b>example: </b>SHoundProteinsFromTaxIDIII(10665);<br>
<a href=apifunctslist.html#SHoundProteinsFromTaxIDIII>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromTaxIDList>SHoundProteinsFromTaxIDList</a></h2>
<br><b>description: </b>Gets all protein GI identifiers from a list of organisms.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer taxonomy identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinsFromTaxIDList(ValNodePtr  pvntaxid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer taxonomy identifiers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundProteinsFromTaxIDList(list<int>& stltaxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of taxonomy identifiers<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundProteinsFromTaxIDList(10665);<br>
<a href=apifunctslist.html#SHoundProteinsFromTaxIDList>list of functions</a><br><br>

<br><h2><a name=SHoundTaxIDFrom3D>SHoundTaxIDFrom3D</a></h2>

<br><b>description: </b>Converts a structural identifier to one or more taxonomy identifiers.   Reports which organism(s) the 3-D
structure comes from.<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer MMDB identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundTaxIDFrom3D(Int4 mmdbid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer MMDB identifier<br>
<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundTaxIDFrom3D(int mmdbid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>MMDB identifier<br>
<b>return: </b>comma delimited  list of taxonomy identifiers or zero<br>

<b>example: </b>SHoundTaxIDFrom3D(11);<br>
<a href=apifunctslist.html#SHoundTaxIDFrom3D>list of functions</a><br><br>

<br><h2><a name=SHoundTaxIDFrom3DList>SHoundTaxIDFrom3DList</a></h2>
<br><b>description: </b>Converts a list of structural identifiers to a list of taxonomy identifiers.  Reports which organisms the 3-D
structures come from.<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer MMDB identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundTaxIDFrom3DList(ValNodePtr pvnMmdbid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer MMDB identifiers<br>

<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundTaxIDFrom3DList(list<int>& stlmmdb);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited  list of MMDB identifiers<br>
<b>return: </b>comma delimited  list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundTaxIDFrom3DList("11,12");<br>

<a href=apifunctslist.html#SHoundTaxIDFrom3DList>list of functions</a><br><br>
<br><h2><a name=SHoundTaxIDFromGi>SHoundTaxIDFromGi</a></h2>

<br><b>description: </b>Converts a GI identifier to an NCBI taxonomy identifier. Reports which organism a given sequence is from.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer taxonomy identifier, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHoundTaxIDFromGi(Int4 Gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer taxonomy identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was
not found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundTaxIDFromGi(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI sequence identifier<br>
<b>return: </b>taxonomy identifier or zero<br>

<b>example: </b>SHoundTaxIDFromGi(32);<br>
<a href=apifunctslist.html#SHoundTaxIDFromGi>list of functions</a><br><br>


<br><h2><a name=SHoundTaxIDFromGiList>SHoundTaxIDFromGiList</a></h2>

<br><b>description: </b>Converts a list of GI identifiers to a list of NCBI taxonomy identifier  Reports which organisms given sequences
 are from.<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundTaxIDFromGiList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundTaxIDFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited  list of GI identifiers<br>
<b>return: </b>comma delimited  list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundTaxIDFromGiList("324,32");<br>
<a href=apifunctslist.html#SHoundTaxIDFromGiList>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_2>COMPLETE GENOME ITERATORS</a></h1><br><br>These functions returns lists of things that pertain to completely sequenced
genomes.  For example, given a taxon identifier, these functions can retrieve a complete list of protein, nucleic acid or chromosome records associated
with the completely sequenced genome for that organism.<br><br>





<br><h2><a name=SHoundAllGenomes>SHoundAllGenomes</a></h2>

<br><b>description: </b>Gets a list of taxonomy identifiers for all complete genomes present in the SeqHound system. Complete genome
annotations are available from NCBI.<br>

<br><br><b>C</b><br>

<b>arguments: </b>void<br>
<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundAllGenomes(void);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>void<br>
<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundAllGenomes(void);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>none<br>

<b>return: </b>comma delimited list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundAllGenomes();<br>
<a href=apifunctslist.html#SHoundAllGenomes>list of functions</a><br><br>

<br><h2><a name=SHoundChromosomeFromGenome>SHoundChromosomeFromGenome</a></h2>

<br><b>description: </b>Gets a list of DNA molecules from a complete genome.  The desired return types of DNA molecules can be
filtered.<br>

<br><br><b>C</b><br>

<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>integer taxonomy identifier and a Byte representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to a ValNode linked list of integer chromosomal identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundChromosomeFromGenome(Int4 taxid, Byte chromflags);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>integer taxonomy identifier and a unsigned char representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to an STL list of integer chromosomal identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundChromosomeFromGenome(int taxid, unsigned char  chromflags);<br>

<br><br><b>PERL</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte  flags" where each bit is reserved for one kind of DNA molecule:
<br>             1 is chromosome
<br>             2 is mitochondrion
<br>             4 is chloroplast
<br>             8 is plasmid
<br>             16 is extra-chromosomal element
<br>             32 is undefined
<br>             64 is phage
<br>             128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>taxonomy identifier and a filter integer representing different kinds of DNA molecule (see comment)<br>
<b>return: </b>comma delimited list of chromosomal identifiers or zero<br>
<b>example: </b>SHoundChromosomeFromGenome(155864, 1);<br>

<a href=apifunctslist.html#SHoundChromosomeFromGenome>list of functions</a><br><br>
<br><h2><a name=SHoundChromosomeFromGenomeList>SHoundChromosomeFromGenomeList</a></h2>

<br><b>description: </b>Gets a list of DNA molecules from a complete genome list.  The desired return types of DNA molecules can be
filtered.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>







<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>pointer to a ValNode linked list of integer taxonomy identifiers and a Byte representation of different kinds of DNA molecules (see
comment)<br>
<b>return: </b>pointer to a ValNode linked list of integer chromosomal identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundChromosomeFromGenomeList(ValNodePtr pvnGenom, Byte chromflags);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>reference to an STL list of integer taxonomy identifiers and a unsigned char representation of different kinds of DNA molecules (see
comment)<br>
<b>return: </b>pointer to an STL list of integer chromosomal identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundChromosomeFromGenomeList(list<int>& stlGenome, unsigned char  chromflags);<br>

<br><br><b>PERL</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte  flags" where each bit is reserved for one kind of DNA molecule:
<br>             1 is chromosome
<br>             2 is mitochondrion
<br>             4 is chloroplast
<br>             8 is plasmid
<br>             16 is extra-chromosomal element
<br>             32 is undefined
<br>             64 is phage
<br>             128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>comma delimited list of taxonomy identifiers and a filter integer representing different kinds of DNA molecule (see comment)<br>

<b>return: </b>comma delimited list of chromosomal identifiers or zero<br>
<b>example: </b>SHoundChromosomeFromGenomeList("155864", 1);<br>
<a href=apifunctslist.html#SHoundChromosomeFromGenomeList>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromChromosome>SHoundDNAFromChromosome</a></h2>

<br><b>description: </b>Gets all DNA identifiers from one DNA molecule such as chromosome, plasmid etc.  The resulting DNA identifiers
constitute a subset of complete genome annotation available from NCBI.<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer chromosomal identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromChromosome(Int4 chromid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundDNAFromChromosome(int chromid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>chromosomal identifier<br>

<b>return: </b>comma delimited list of DNA GI identifiers or zero<br>
<b>example: </b>SHoundDNAFromChromosome(169);<br>
<a href=apifunctslist.html#SHoundDNAFromChromosome>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromChromosomeList>SHoundDNAFromChromosomeList</a></h2>

<br><b>description: </b>Gets all DNA identifiers from a list DNA molecules such as chromosomes, plasmids etc. The resulting DNA
identifiers constitute a subset of complete genome annotation available from NCBI.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromChromosomeList(ValNodePtr pvnChrom);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>ist<int> SHoundDNAFromChromosomeList(list<int>& stlchrom);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of chromosomal identifiers<br>
<b>return: </b>comma delimited  list of DNA GI identifiers or zero<br>

<b>example: </b>SHoundDNAFromChromosomeList("169,132");<br>
<a href=apifunctslist.html#SHoundDNAFromChromosomeList>list of functions</a><br><br>

<br><h2><a name=SHoundDNAFromOrganism>SHoundDNAFromOrganism</a></h2>
<br><b>description: </b>Gets all DNA identifiers from a complete genome annotation. Complete genome annotations are available from
NCBI.<br>


<br><br><b>C</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>integer taxonomy identifier and a Byte representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromOrganism(Int4 taxid, Byte chromflags);<br>

<br><br><b>C++</b><br>





<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>integer taxonomy identifier and a unsigned char representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundDNAFromOrganism(int taxid, unsigned char chromflags);<br>

<br><br><b>PERL</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecule:
<br>             1 is chromosome
<br>             2 is mitochondrion
<br>             4 is chloroplast
<br>             8 is plasmid
<br>             16 is extra-chromosomal element
<br>             32 is undefined
<br>             64 is phage
<br>             128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>taxonomy identifier and a filter integer representing different kinds of DNA molecule (see comment)<br>
<b>return: </b>comma delimited list of DNA GI identifiers or zero<br>
<b>example: </b>SHoundDNAFromOrganism(155864, 1);<br>

<a href=apifunctslist.html#SHoundDNAFromOrganism>list of functions</a><br><br>
<br><h2><a name=SHoundDNAFromOrganismList>SHoundDNAFromOrganismList</a></h2>

<br><b>description: </b>Gets all DNA identifiers from a complete genomes list. Complete genome annotations are available from NCBI.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>pointer to a ValNode linked list of integer taxonomy identifiers and a Byte representation of different kinds of DNA molecules (see
comment)<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundDNAFromOrganismList(ValNodePtr pvnTax, Byte chromflags);<br>
<br><br><b>C++</b><br>







<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>reference to an STL list of integer taxonomy identifiers and a unsigned char representation of different kinds of DNA molecules (see
comment)<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundDNAFromOrganismList(list<int>& stltaxid, unsigned char  chromflags);<br>

<br><br><b>PERL</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecule:
<br>             1 is chromosome
<br>             2 is mitochondrion
<br>             4 is chloroplast
<br>             8 is plasmid
<br>             16 is extra-chromosomal element
<br>             32 is undefined
<br>             64 is phage
<br>             128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>comma delimited list of taxonomy identifiers and a filter integer representing different kinds of DNA molecule (see comment)<br>

<b>return: </b>comma delimited list of DNA GI identifiers or zero<br>
<b>example: </b>SHoundDNAFromOrganismList("155864,139", 1);<br>
<a href=apifunctslist.html#SHoundDNAFromOrganismList>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromChromosome>SHoundProteinsFromChromosome</a></h2>

<br><b>description: </b>Gets all protein GI identifiers from one DNA molecule such as chromosome, plasmid etc.  The resulting protein GI
 identifiers constitute a subset of complete genome annotation available from NCBI.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinsFromChromosome(Int4 chromid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundProteinsFromChromosome(int chromid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>chromosomal identifier<br>
<b>return: </b>comma delimited list of protein GI identifiers or zero<br>

<b>example: </b>SHoundProteinsFromChromosome(169);<br>
<a href=apifunctslist.html#SHoundProteinsFromChromosome>list of functions</a><br><br>





<br><h2><a name=SHoundProteinsFromChromosomeList>SHoundProteinsFromChromosomeList</a></h2>

<br><b>description: </b>Gets all protein GI identifiers from a list DNA molecules such as chromosomes, plasmids etc. The resulting
protein GI identifiers constitute a subset of complete genome annotation available from NCBI.<br>

<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundProteinsFromChromosomeList(ValNodePtr pvnChrom);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer chromosomal identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>ist<int> SHoundProteinsFromChromosomeList(list<int>& stlchrom);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of chromosomal identifiers<br>

<b>return: </b>comma delimited  list of protein GI identifiers or zero<br>
<b>example: </b>SHoundProteinsFromChromosomeList("169,132");<br>
<a href=apifunctslist.html#SHoundProteinsFromChromosomeList>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromOrganism>SHoundProteinsFromOrganism</a></h2>

<br><b>description: </b>Gets all protein GI identifiers from a complete genome annotation. Complete genome annotations are available
from NCBI.<br>

<br><br><b>C</b><br>

<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>
<b>arguments: </b>integer taxonomy identifier and a Byte representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundProteinsFromOrganism(Int4 taxid, Byte chromflags);<br>
<br><br><b>C++</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>integer taxonomy identifier and a unsigned char representation of different kinds of DNA molecules (see comment)<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundProteinsFromOrganism(int taxid, unsigned char chromflags);<br>
<br><br><b>PERL</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecule:
<br> 1 is chromosome
<br> 2 is mitochondrion
<br> 4 is chloroplast
<br> 8 is plasmid
<br>16 is extra-chromosomal element
<br>32 is undefined
<br>64 is phage
<br>128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>taxonomy identifier and a filter integer representing different kinds of DNA molecule (see comment)<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundProteinsFromOrganism(155864, 1);<br>
<a href=apifunctslist.html#SHoundProteinsFromOrganism>list of functions</a><br><br>

<br><h2><a name=SHoundProteinsFromOrganismList>SHoundProteinsFromOrganismList</a></h2>
<br><b>description: </b>Gets all protein GI identifiers from a complete genomes list. Complete genome annotations are available from
NCBI.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>pointer to a ValNode linked list of integer taxonomy identifiers and a Byte representation of different kinds of DNA molecules<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundProteinsFromOrganismList(ValNodePtr pvnTax, Byte chromflags);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecules:
<br>#define CHROM_PHAGE 0x40  //phage
<br>#define CHROM_NR    0x20  //not used
<br>#define CHROM_ECE   0x10  //extra-chromosomal element
<br>#define CHROM_PLMD  0x08  //plasmid
<br>#define CHROM_CHLO  0x04  //chloroplast
<br>#define CHROM_MITO  0x02  //mitochondrion
<br>#define CHROM_CHROM 0x01  //chromosome
<br>#define CHROM_ALL   0xFF  //all<br>

<b>arguments: </b>reference to an STL list of integer taxonomy identifiers and a unsigned char representation of different kinds of DNA molecules<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundProteinsFromOrganismList(list<int>& stltaxid, unsigned char  chromflags);<br>

<br><br><b>PERL</b><br>





<b>comment: </b>The arguments concerning DNA molecule type are so called "byte flags" where each bit is reserved for one kind of DNA molecule:
<br>             1 is chromosome
<br>             2 is mitochondrion
<br>             4 is chloroplast
<br>             8 is plasmid
<br>             16 is extra-chromosomal element
<br>             32 is undefined
<br>             64 is phage
<br>             128 is undefined
<br>the flags are additive; for example 255 means that all kinds of DNA molecules in a given organism are requested<br>

<b>arguments: </b>comma delimited list of taxonomy identifiers and a filter integer representing different kinds of DNA molecule<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundProteinsFromOrganismList("155864,139", 1);<br>

<a href=apifunctslist.html#SHoundProteinsFromOrganismList>list of functions</a><br><br>
<br><br><h1><a name=SECTIONID_6>REDUNDANT (EQUIVALENT) SEQUENCES</a></h1><br><br>Sequence records in GenBank are redundant.  For example, two different
sets of authors may submit the same sequence to GenBank.  Both groups will be given different sequence record identifiers (GI's).  SeqHound, groups
sequences that are exactly the same under a single identifier (Redundant Group Identifier).  These functions allow the programmer to find the Redundant
Group that a sequence record (GI) belongs to and then retrieve all of the other sequences that belong to the same group.  This set of functions is useful
when trying to collect all of the annotation that applies to a biological sequence but may be scattered across several sequence records.<br><br>











<br><h2><a name=SHoundFirstOfRedundantGroupFromID>SHoundFirstOfRedundantGroupFromID</a></h2>

<br><b>description: </b>Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different
annotations. The function gets a representative entry (generally the one with best annotation such as PDB, RefSeq or SwissProt entry)
given a redundant group identifier. The redundant group identifiers can only be used temporarily, they change every day.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer redundant group identifier<br>

<b>return: </b>integer GI identifier, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHoundFirstOfRedundantGroupFromID(Int4 group);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer redundant group identifier<br>
<b>return: </b>integer GI identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not
found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundFirstOfRedundantGroupFromID(int group);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>redundant group identifier<br>
<b>return: </b>GI protein identifier or zero<br>
<b>example: </b>SHoundFirstOfRedundantGroupFromID(362477);<br>

<a href=apifunctslist.html#SHoundFirstOfRedundantGroupFromID>list of functions</a><br><br>



<br><h2><a name=SHoundFirstOfRedundantGroupFromIDList>SHoundFirstOfRedundantGroupFromIDList</a></h2>

<br><b>description: </b>Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different
annotations. The function gets a list of representative entries (generally the one with best annotation such as PDB, RefSeq or SwissProt
 entry) given a list of redundant group identifiers.  The redundant group identifiers can only be used temporarily, they change every
day.<br>
<b>comment: </b>The order in the lists is not maintained.<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer redundant group identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundFirstOfRedundantGroupFromIDList(ValNodePtr pvngroup);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer redundant group identifiers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundFirstOfRedundantGroupFromIDList(list<int>& stlgroup);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of redundant group identifiers<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundFirstOfRedundantGroupFromIDList("362477,408917");<br>
<a href=apifunctslist.html#SHoundFirstOfRedundantGroupFromIDList>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroup>SHoundRedundantGroup</a></h2>

<br><b>description: </b>Gets all protein entries with the same sequence from the system.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundRedundantGroup(Int4 Gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundRedundantGroup(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI protein identifier<br>
<b>return: </b>a comma delimited list of protein GI identifiers or zero<br>

<b>example: </b>$result = SHoundRedundantGroup(32);<br>
<a href=apifunctslist.html#SHoundRedundantGroup>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroupFromID>SHoundRedundantGroupFromID</a></h2>
<br><b>description: </b>Gets a list of redundant protein sequences from a redundant group identifier.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.  The redundant
 group identifiers can only be used temporarily, they change every day.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer redundant group identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr LIBCALL SHoundRedundantGroupFromID(Int4 group);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer redundant group identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundRedundantGroupFromID(int group);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>redundant group identifier<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundRedundantGroupFromID(362477);<br>
<a href=apifunctslist.html#SHoundRedundantGroupFromID>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroupFromIDList>SHoundRedundantGroupFromIDList</a></h2>

<br><b>description: </b>Gets a list of redundant protein sequences from a list of redundant group identifiers.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations. The redundant
group identifiers can only be used temporarily, they change every day.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer redundant group identifiers<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundRedundantGroupFromIDList(ValNodePtr pvngroup);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer redundant group identifiers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundRedundantGroupFromIDList(list<int>& stlgroup);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of redundant group identifiers<br>
<b>return: </b>comma delimited list of protein GI identifiers or zero<br>

<b>example: </b>SHoundRedundantGroupFromIDList("32,362477");<br>
<a href=apifunctslist.html#SHoundRedundantGroupFromIDList>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroupIDFromGI>SHoundRedundantGroupIDFromGI</a></h2>
<br><b>description: </b>Gets an arbitrary redundant group identifier for a protein sequence.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.  The redundant
 group identifiers can only be used temporarily, they change every day.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>integer redundant group identifier , -1 if not found or zero<br>

<b>prototype: </b>Int4 SHoundRedundantGroupIDFromGI(Int4 Gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>integer redundant group identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value
 was not found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundRedundantGroupIDFromGI(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>

<b>return: </b>redundant group identifier or zero<br>
<b>example: </b>SHoundRedundantGroupIDFromGI(32);<br>
<a href=apifunctslist.html#SHoundRedundantGroupIDFromGI>list of functions</a><br><br>


<br><h2><a name=SHoundRedundantGroupIDFromGIList>SHoundRedundantGroupIDFromGIList</a></h2>

<br><b>description: </b>Gets an arbitrary redundant group identifier for a list of protein sequences.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.  The redundant
 group identifiers can only be used temporarily, they change every day.<br>
<b>comment: </b>The order in the lists is not maintained.<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer redundant group identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundRedundantGroupIDFromGIList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to an STL list of integer redundant group identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundRedundantGroupIDFromGIList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of protein GI identifiers<br>

<b>return: </b>comma delimited list of redundant group identifiers or zero<br>
<b>example: </b>SHoundRedundantGroupIDFromGIList("32,6017926");<br>
<a href=apifunctslist.html#SHoundRedundantGroupIDFromGIList>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroupKeyedList>SHoundRedundantGroupKeyedList</a></h2>

<br><b>description: </b>Gets all protein GI identifiers with the same sequence as the query protein GI identifier.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.<br>



<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of protein GI identifiers<br>

<b>return: </b>a hash table, each entry of the table stores a query protein GI identifier and its associated list of redundant group protein GI
identifiers.
<br>or an empty hash table if failure<br>
<b>example: </b>%hash = SHoundRedundantGroupKeyedList("4557225,234,123");<br>
<a href=apifunctslist.html#SHoundRedundantGroupKeyedList>list of functions</a><br><br>

<br><h2><a name=SHoundRedundantGroupList>SHoundRedundantGroupList</a></h2>
<br><b>description: </b>Gets all protein entries with the same sequence from the system for a list of protein sequences.
Entrez collection of databases contains redundant entries i.e. proteins with the same sequence but different annotations.<br>



<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundRedundantGroupList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundRedundantGroupList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of protein GI identifiers<br>
<b>return: </b>comma delimited list of protein GI identifiers or zero<br>
<b>example: </b>SHoundRedundantGroupList("32,4586891");<br>
<a href=apifunctslist.html#SHoundRedundantGroupList>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_20>TAXONOMY</a></h1><br><br>This set of functions allows the programmer to traverse the NCBI taxonomy tree.<br><br>



<br><h2><a name=SHoundGetAllTaxAncestors>SHoundGetAllTaxAncestors</a></h2>
<br><b>description: </b>Operates on NCBI's taxonomy tree.  It retrieves all taxons (the whole subtree) situated above a given taxon in
the taxonomy tree.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetAllTaxAncestors(Int4 taxId);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>

<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGetAllTaxAncestors(int taxid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>comma delimited list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundGetAllTaxAncestors(10665);<br>

<a href=apifunctslist.html#SHoundGetAllTaxAncestors>list of functions</a><br><br>
<br><h2><a name=SHoundGetAllTaxProgeny>SHoundGetAllTaxProgeny</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.  It retrieves all taxons (the whole subtree) situated below a given taxon in
the taxonomy tree.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetAllTaxProgeny(Int4 taxId);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGetAllTaxProgeny(int taxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>

<b>return: </b>comma delimited list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundGetAllTaxProgeny(10665);<br>
<a href=apifunctslist.html#SHoundGetAllTaxProgeny>list of functions</a><br><br>

<br><h2><a name=SHoundGetTaxChildNodes>SHoundGetTaxChildNodes</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.  Retrieves all taxons situated directly below a given taxon in the taxonomy
tree.<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer taxonomy identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer taxonomy identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetTaxChildNodes(Int4 taxId);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGetTaxChildNodes(int taxid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>comma delimited list of taxonomy identifiers or zero<br>

<b>example: </b>SHoundGetTaxChildNodes(10665);<br>
<a href=apifunctslist.html#SHoundGetTaxChildNodes>list of functions</a><br><br>

<br><h2><a name=SHoundGetTaxChildNodesList>SHoundGetTaxChildNodesList</a></h2>
<br><b>description: </b>Operates on NCBI's taxonomy tree.  Retrieves all taxons situated directly below a list of taxons in the taxonomy
 tree.<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer taxonomy identifiers<br>
<b>return: </b>ValNode linked list of integer taxonomy identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetTaxChildNodesList(ValNodePtr taxIdList);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer taxonomy identifiers<br>

<b>return: </b>pointer to an STL list of integer taxonomy identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGetTaxChildNodesList(list<int>& sltTaxid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of taxonomy identifiers<br>
<b>return: </b>comma delimited list of taxonomy identifiers or zero<br>
<b>example: </b>SHoundGetTaxChildNodesList("10665");<br>

<a href=apifunctslist.html#SHoundGetTaxChildNodesList>list of functions</a><br><br>
<br><h2><a name=SHoundGetTaxLineageFromTaxID>SHoundGetTaxLineageFromTaxID</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.   Retrieves lineage information in a specified style.<br>


<br><br><b>C</b><br>

<b>comment: </b>Lineage form can be specified as follows:
<br>#define SHoundGetTaxLineage_FULL 10        //full lineage
<br>#define SHoundGetTaxLineage_GENBANK 20     //lineage as it appears in GenBank record
<br>#define SHoundGetTaxLineagee_TAXDBSHORT 30 //lineage as it would appear on the taxonomy database home page<br>
<b>arguments: </b>integer taxonomy identifier and an integer representing a defined lineage style (e.g. "SHoundGetTaxLineage_GENBANK")<br>

<b>return: </b>pointer to a string containing lineage or NULL<br>
<b>prototype: </b>CharPtr SHoundGetTaxLineageFromTaxID(Int4 taxId, Uint2 type);<br>

<br><br><b>C++</b><br>
<b>comment: </b>Lineage form can be specified as follows:
<br>#define SHoundGetTaxLineage_FULL 10        //full lineage
<br>#define SHoundGetTaxLineage_GENBANK 20     //lineage as it appears in GenBank record
<br>#define SHoundGetTaxLineagee_TAXDBSHORT 30 //lineage as it would appear on the taxonomy database home page<br>
<b>arguments: </b>integer taxonomy identifier and an integer representing a defined lineage style (e.g. "SHoundGetTaxLineage_GENBANK")<br>

<b>return: </b>string taxonomy name or an empty string<br>
<b>prototype: </b>string SHoundGetTaxLineageFromTaxID(int taxid, int type);<br>
<br><br><b>PERL</b><br>
<b>comment: </b>Lineage filters:
<br>SHoundGetTaxLineage_FULL --   gets full lineage
<br>SHoundGetTaxLineage_GENBANK -- gets lineage as it appears in GenBank record
<br>SHoundGetTaxLineage_TAXDBSHORT - gets lineage as it would appear on the taxonomy database home page<br>

<b>arguments: </b>taxonomy identifier and lineage filter (e.g. "TAXDB_GetLineage_GENBANK")<br>
<b>return: </b>lineage or zero<br>
<b>example: </b>SHoundGetTaxLineageFromTaxID(9606, "SHoundGetTaxLineage_FULL");<br>
<a href=apifunctslist.html#SHoundGetTaxLineageFromTaxID>list of functions</a><br><br>

<br><h2><a name=SHoundGetTaxNameFromTaxID>SHoundGetTaxNameFromTaxID</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.   Retrieves taxonomy name in scientific form.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>pointer to a string containing scientific name or NULL<br>

<b>prototype: </b>CharPtr SHoundGetTaxNameFromTaxID(Int4 taxId);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>

<b>return: </b>string taxonomy name or an empty string<br>
<b>prototype: </b>string SHoundGetTaxNameFromTaxID(int taxid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>scientific taxonomy name or zero<br>
<b>example: </b>SHoundGetTaxNameFromTaxID(9606);<br>

<a href=apifunctslist.html#SHoundGetTaxNameFromTaxID>list of functions</a><br><br>
<br><h2><a name=SHoundGetTaxNameFromTaxIDByClass>SHoundGetTaxNameFromTaxIDByClass</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.   Retrieves taxonomy name in specified style.<br>


<br><br><b>C</b><br>
<b>comment: </b>The name form can be specified using the following defines:
<br>#define SLRI_taxon_name_name_class_none 0
<br>#define SLRI_taxon_name_name_class_acronym 1
<br>#define SLRI_taxon_name_name_class_anamorph 2
<br>#define SLRI_taxon_name_name_class_blast_name 3
<br>#define SLRI_taxon_name_name_class_common_name 4
<br>#define SLRI_taxon_name_name_class_equivalent_name 5
<br>#define SLRI_taxon_name_name_class_includes 6
<br>#define SLRI_taxon_name_name_class_in_part 7
<br>#define SLRI_taxon_name_name_class_misnomer 8
<br>#define SLRI_taxon_name_name_class_misspelling 9
<br>#define SLRI_taxon_name_name_class_preferred_acronym 10
<br>#define SLRI_taxon_name_name_class_preferred_common_name 11
<br>#define SLRI_taxon_name_name_class_scientific_name 12
<br>#define SLRI_taxon_name_name_class_synonym 13
<br>#define SLRI_taxon_name_name_class_teleomorph 14

<b>arguments: </b>integer taxonomy identifier and an integer representing a defined style (e.g. "SLRI_taxon_name_name_class_preferred_common_name")<br>

<b>return: </b>pointer to a string containing taxonomy name or NULL<br>
<b>prototype: </b>CharPtr SHoundGetTaxNameFromTaxIDByClass(Int4 taxId, Uint2 nameClass);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The name form can be specified using the following defines:
<br>#define SLRI_taxon_name_name_class_none 0
<br>#define SLRI_taxon_name_name_class_acronym 1
<br>#define SLRI_taxon_name_name_class_anamorph 2
<br>#define SLRI_taxon_name_name_class_blast_name 3
<br>#define SLRI_taxon_name_name_class_common_name 4
<br>#define SLRI_taxon_name_name_class_equivalent_name 5
<br>#define SLRI_taxon_name_name_class_includes 6
<br>#define SLRI_taxon_name_name_class_in_part 7
<br>#define SLRI_taxon_name_name_class_misnomer 8
<br>#define SLRI_taxon_name_name_class_misspelling 9
<br>#define SLRI_taxon_name_name_class_preferred_acronym 10
<br>#define SLRI_taxon_name_name_class_preferred_common_name 11
<br>#define SLRI_taxon_name_name_class_scientific_name 12
<br>#define SLRI_taxon_name_name_class_synonym 13
<br>#define SLRI_taxon_name_name_class_teleomorph 14

<b>arguments: </b>integer taxonomy identifier and an integer representing a defined style (e.g. "SLRI_taxon_name_name_class_preferred_common_name")<br>

<b>return: </b>string taxonomy name or an empty string<br>
<b>prototype: </b>string SHoundGetTaxNameFromTaxID(int taxid);<br>

<br><br><b>PERL</b><br>
<b>comment: </b>Class filters usable:
<br>SLRI_taxon_name_name_class_none
<br>SLRI_taxon_name_name_class_acronym
<br>SLRI_taxon_name_name_class_anamorph
<br>SLRI_taxon_name_name_class_blast_name
<br>SLRI_taxon_name_name_class_common_name
<br>SLRI_taxon_name_name_class_equivalent_name
<br>SLRI_taxon_name_name_class_includes
<br>SLRI_taxon_name_name_class_in_part
<br>SLRI_taxon_name_name_class_misnomer
<br>SLRI_taxon_name_name_class_misspelling
<br>SLRI_taxon_name_name_class_preferred_acronym
<br>SLRI_taxon_name_name_class_preferred_common_name
<br>SLRI_taxon_name_name_class_scientific_name
<br>SLRI_taxon_name_name_class_synonym
<br>SLRI_taxon_name_name_class_teleomorph
<b>arguments: </b>taxonomy identifier and a style filter (e.g. "SLRI_taxon_name_name_class_preferred_common_name")<br>

<b>return: </b>taxonomy name or zero<br>
<b>example: </b>SHoundGetTaxNameFromTaxIDByClass(9606, "SLRI_taxon_name_name_class_preferred_common_name");<br>
<a href=apifunctslist.html#SHoundGetTaxNameFromTaxIDByClass>list of functions</a><br><br>

<br><h2><a name=SHoundGetTaxParent>SHoundGetTaxParent</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree.   Retrieves the taxon situated directly above a given taxon in the taxonomy
tree.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>integer taxonomy identifier, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHoundGetTaxParent(Int4 taxId);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>integer taxonomy identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was
not found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundGetTaxParent(int taxid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>taxonomy identifier or zero<br>
<b>example: </b>SHoundGetTaxParent(10665);<br>

<a href=apifunctslist.html#SHoundGetTaxParent>list of functions</a><br><br>
<br><h2><a name=SHoundIsTaxDeleted>SHoundIsTaxDeleted</a></h2>

<br><b>description: </b>Operates on NCBI's taxonomy tree. Reports if a given taxon has been deleted.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer taxonomy identifier<br>

<b>return: </b>boolean TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundIsTaxDeleted(Int4 taxId);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>boolean true if success or false<br>
<b>prototype: </b>bool SHoundIsTaxDeleted(int taxid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>"TRUE" if success or "FALSE"<br>

<b>example: </b>SHoundIsTaxDeleted(10665);<br>
<a href=apifunctslist.html#SHoundIsTaxDeleted>list of functions</a><br><br>

<br><h2><a name=SHoundIsTaxMerged>SHoundIsTaxMerged</a></h2>
<br><b>description: </b>Operates on NCBI's taxonomy tree. Reports if a given taxon has been renamed.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>boolean TRUE if success or FALSE<br>
<b>prototype: </b>Boolean SHoundIsTaxMerged(Int4 taxId);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer taxonomy identifier<br>
<b>return: </b>boolean true if success or false<br>

<b>prototype: </b>bool SHoundIsTaxMerged(int taxid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>"TRUE" if success or "FALSE"<br>

<b>example: </b>SHoundIsTaxMerged(10665);<br>
<a href=apifunctslist.html#SHoundIsTaxMerged>list of functions</a><br><br>









<br><br><h1><a name=SECTIONID_18>SEQUENCE NEIGHBOURS</a></h1><br><br>This set of functions retrieves sequence neighbours and sequence alignments given a
GenInfo (GI) identifier of a protein.  The non-redundant set of protein sequence records in SeqHound are used to precompute neighbours and alignments that
are stored by SeqHound.  This process is described in the NBLAST paper available in BioMed Central.<br><br>







<br><h2><a name=SHound3DNeighboursFromGi>SHound3DNeighboursFromGi</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours possessing 3-D structure.  Uses redundancy information for the
query protein.  This means that if the query fails for the input GI identifier, then the query will be retried for all other GI
identifiers that belong to the same redundant group.

 The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of structural
 (MMDB) identifiers<br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>integer GI protein identifier, memory address for the results (pointer to ILinkSetPtr), float E-value cutoff<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHound3DNeighboursFromGi(Int4 gi, ILinkSetPtr PNTR p3DNeighbours, FloatHi evalue);<br>
<br><br><b>C++</b><br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of structural
 (MMDB) identifiers<br>
<b>arguments: </b>integer GI protein identifier, reference for the result (CFLink_set_List3), float E-value cutoff<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHound3DNeighboursFromGi(int gi, CILink_set& p3DNeighbours, float  evalue);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>protein GI identifier, E-value cutoff<br>
<b>return: </b>sequence neighbours as comma delimited list of GI identifiers or zero if failure<br>

<b>example: </b>SHound3DNeighboursFromGi(68502, 0.01);<br>
<a href=apifunctslist.html#SHound3DNeighboursFromGi>list of functions</a><br><br>

<br><h2><a name=SHound3DNeighboursFromGiEx>SHound3DNeighboursFromGiEx</a></h2>
<br><b>description: </b><br>





<a href=apifunctslist.html#SHound3DNeighboursFromGiEx>list of functions</a><br><br>


<br><h2><a name=SHound3DNeighboursFromGiList>SHound3DNeighboursFromGiList</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours possessing 3-D structure using a list of proteins as a query.  Uses
 redundancy information for the query protein. This means that if the query fails for the input GI identifier, then the query will be
retried for all other GI identifiers that belong to the same redundant group.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
(MMDB) structural identifiers<br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers, memory address for the results (pointer to ILinkSetList), float E-value
cutoff<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHound3DNeighboursFromGiList(ValNodePtr pvngilist, ILinkSetListPtr PNTR p3DNeighboursList, FloatHi evalue);<br>


<br><br><b>C++</b><br>
<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
(MMDB) structural identifiers<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>reference to an STL list of integer GI identifiers, reference for the result (CILink_set_List2), float E-value cutoff<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHound3DNeighboursFromGiList(list<int> stlGi, CILink_set_List2& pNeighbours, float evalue);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of protein GI  identifiers (e.g. 4557225, 6009729)
<br>an evalue (e.g. 1.0)<br>
<b>return: </b>sequence neighbours as comma delimited list of GI identifiers or zero if failure<br>
<b>example: </b>SHound3DNeighboursFromGiList("68502,266373", 0.01);<br>

<a href=apifunctslist.html#SHound3DNeighboursFromGiList>list of functions</a><br><br>
<br><h2><a name=SHound3DNeighboursFromTaxID>SHound3DNeighboursFromTaxID</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours possessing 3-D structure using a list of proteins belonging to a
complete genome as a query. Uses redundancy information for the query protein.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>

<br><br><b>C</b><br>

<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
(MMDB) structural identifiers<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>integer taxonomy identifier, memory address for the results (pointer to ILinkSetList), float E-value cutoff<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHound3DNeighboursFromTaxID(Int4 TaxID, ILinkSetListPtr PNTR p3DNeighboursList, FloatHi evalue);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
(MMDB) structural identifiers<br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>integer taxonomy identifier, reference for the result (CILink_set_List2), float E-value cutoff<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHound3DNeighboursFromTaxID(int taxid, CILink_set_List2& p3DNeighbours, float evalue);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>taxonomy identifier, E-value cutoff<br>
<b>return: </b>sequence neighbours as comma delimited list of GI identifiers<br>
<b>example: </b>SHound3DNeighboursFromTaxID(2097, 0.01);<br>

<a href=apifunctslist.html#SHound3DNeighboursFromTaxID>list of functions</a><br><br>
<br><h2><a name=SHoundGetBlastResult>SHoundGetBlastResult</a></h2>

<br><b>description: </b>Retrieves summary information about a BLAST alignment between two protein sequences.<br>


<br><br><b>C</b><br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>pair of integer GI identifiers and a memory address for the result ( pointer to NBlastResultSet)<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundGetBlastResult (Int4 gi1, Int4 gi2, NBlastResultSetPtr PNTR ppResult)<br>

<br><br><b>C++</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>pair of integer GI identifiers and a reference for the result (CNBlast_Result_Set)<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundGetBlastResult(int gi1, int gi2, CNBlast_Result_Set& pResult)<br>
<a href=apifunctslist.html#SHoundGetBlastResult>list of functions</a><br><br>

<br><h2><a name=SHoundGetBlastSeqAlign>SHoundGetBlastSeqAlign</a></h2>
<br><b>description: </b>Retrieves detailed information about a BLAST alignment between two protein sequences.<br>



<br><br><b>C</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>pair of integer GI identifiers and a memory address for the result ( pointer to SeqAlign)<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>

<b>prototype: </b>SLRI_ERR SHoundGetBlastSeqAlign(Int4 gi1, Int4 gi2, SeqAlignPtr PNTR psap)<br>
<br><br><b>C++</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>pair of integer GI identifiers and a reference for the result (CSeq_align)<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundGetBlastSeqAlign(int gi1, int gi2, CSeq_align& psap);<br>
<a href=apifunctslist.html#SHoundGetBlastSeqAlign>list of functions</a><br><br>

<br><h2><a name=SHoundGiAndNumNeighboursList>SHoundGiAndNumNeighboursList</a></h2>
<br><b>description: </b>Retrieves a number of neighbours for each protein in the database. The BLAST protein neighbours were calculated
using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>comment: </b>The neighbours are stored in a structure which contains the total number of proteins, list of GI identifiers, and a list of counts<br>

<b>arguments: </b>memory address for the results (pointer to ILinkSet)<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR LIBCALL SHoundGiAndNumNeighboursList (ILinkSetPtr PNTR ilsp);<br>
<br><br><b>C++</b><br>
<b>comment: </b>The neighbours are stored in a structure which contains the total number of proteins, list of GI identifiers, and a list of counts<br>


<b>arguments: </b>reference for the result (CILink_set)<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundGiAndNumNeighboursList(CILink_set& pilsp);<br>
<a href=apifunctslist.html#SHoundGiAndNumNeighboursList>list of functions</a><br><br>

<br><h2><a name=SHoundNeighboursFromGi>SHoundNeighboursFromGi</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours.  Uses redundancy information for the query protein.  This means
that if the query fails for the input GI identifier, then the query will be retried for all other GI identifiers that belong to the same
 redundant group.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>

<br><br><b>C</b><br>
<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>


<b>arguments: </b>integer GI protein identifier, memory address for the results (pointer to FLinkSetPtr), float E-value cutoff, boolean TRUE or FALSE
to limit the number of results to one hundred<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundNeighboursFromGi(Int4 gi, FLinkSetPtr PNTR pNeighbours, FloatHi evalue, Boolean bLimit);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of
E-values<br>

<b>arguments: </b>integer GI protein identifier, reference for the result (CFLink_set), float E-value cutoff, boolean true or false to limit the number
of results to one hundred<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNeighboursFromGi(int gi, CFLink_set& pNeighbours, float evalue, bool bLimit);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>protein GI identifier ( e.g. 4557225)
<br>an evalue cutoff  (e.g. 0.5)
<br>"TRUE" to restrict return list to 100, otherwise set limit "FALSE"<br>
<b>return: </b>sequence neighbours as comma delimited list of GI identifiers or zero if failure<br>
<b>example: </b>SHoundNeighboursFromGi(6017926,0.1,"FALSE");<br>

<a href=apifunctslist.html#SHoundNeighboursFromGi>list of functions</a><br><br>
<br><h2><a name=SHoundNeighboursFromGiEx>SHoundNeighboursFromGiEx</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours.  This function does not use redundancy information.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>



<br><br><b>C</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>arguments: </b>integer GI protein identifier, memory address for the results (pointer to FLinkSetPtr), float E-value cutoff, boolean TRUE or FALSE
to limit the number of results to one hundred<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundNeighboursFromGiEx(Int4 gi, FLinkSetPtr PNTR pNeighbours, FloatHi evalue, Boolean bLimit);<br>


<br><br><b>C++</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a structure which contains the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>arguments: </b>integer GI protein identifier, reference for the result (CFLink_set), float E-value cutoff, boolean true or false to limit the number
of results to one hundred<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNeighboursFromGiEx(int gi,CFLink_set& pNeighbours, float evalue,  bool bLimit);<br>

<a href=apifunctslist.html#SHoundNeighboursFromGiEx>list of functions</a><br><br>
<br><h2><a name=SHoundNeighboursFromGiList>SHoundNeighboursFromGiList</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours using a list of proteins as a query.  Uses redundancy information
for the query proteins.  This means that if the query fails for the input GI identifier, then the query will be retried for all other GI
 identifiers that belong to the same redundant group.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>

<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers, memory address for the result (pointer to FLinkSetList), float E-value
cutoff<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>

<b>prototype: </b>SLRI_ERR SHoundNeighboursFromGiList(ValNodePtr gilist, FLinkSetListPtr PNTR pNeighboursList, FloatHi evalue);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>reference to an STL list of integer GI identifiers, reference for the result (CFLink_set_List2), float E-value cutoff<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNeighboursFromGiList(list<int>& stlGi, CFLink_set_List2& pNeighbours, float evalue);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>a comma delimited list of protein GI identifiers ( e.g. "4557225,4501843")
<br>evalue cutoff  (e.g. 0.5)<br>
<b>return: </b>sequence neighbours as comma delimited list of GI identifiers or zero if failure<br>

<b>example: </b>SLRI_ERR SHoundNeighboursFromGiList("6017926,32",0.01);<br>
<a href=apifunctslist.html#SHoundNeighboursFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundNeighboursFromTaxID>SHoundNeighboursFromTaxID</a></h2>
<br><b>description: </b>Retrieves a list of protein BLAST neighbours using a list of proteins belonging to a complete genome as a query.
  Uses redundancy information for the query proteins.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>arguments: </b>integer taxonomy identifier, memory address for the results (pointer to FLinkSetList), float E-value cutoff<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>

<b>prototype: </b>SLRI_ERR SHoundNeighboursFromTaxID(Int4 TaxID, FLinkSetListPtr PNTR pNeighboursList, FloatHi evalue);<br>
<br><br><b>C++</b><br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>
<b>arguments: </b>integer taxonomy identifier, reference for the result (CFLink_set_List2), float E-value cutoff<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNeighboursFromTaxID(int taxid, CFLink_set_List2& pNeighboursList,  float evalue);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>taxonomy identifier, E-value cutoff<br>

<b>return: </b>sequence neighbours as comma delimited list of GI identifiers<br>
<b>example: </b>SHoundNeighboursFromTaxID(2097,0.01);<br>
<a href=apifunctslist.html#SHoundNeighboursFromTaxID>list of functions</a><br><br>

<br><h2><a name=SHoundNeighboursOfNeighbours>SHoundNeighboursOfNeighbours</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours using a list of proteins constituting neighbours to a given protein
 as a query.  Uses redundancy information for the query proteins.  This means that if the query fails for the input GI identifier, then
the query will be retried for all other GI identifiers that belong to the same redundant group.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>integer GI protein identifier, memory address for the results (pointer to FLinkSetList), float E-value cutoff<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundNeighboursOfNeighbours(Int4 gi, FLinkSetListPtr PNTR pGINeighboursList, FloatHi evalue);<br>

<br><br><b>C++</b><br>
<b>comment: </b>The neighbours are stored in a list of structures which contain the total number of neighbours, list of GI identifiers, and a list of
E-values<br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>integer GI protein identifier, reference for the result (CFLink_set_List2), float E-value cutoff<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNeighboursOfNeighbours(int Gi, CFLink_set_List2& pNeighboursList,  float evalue);<br>
<a href=apifunctslist.html#SHoundNeighboursOfNeighbours>list of functions</a><br><br>

<br><h2><a name=SHoundNeighboursOfNeighboursList>SHoundNeighboursOfNeighboursList</a></h2>

<br><b>description: </b>Retrieves a list of protein BLAST neighbours using a list of proteins constituting neighbours to a given list of
 proteins as a query. Uses redundancy information for the query proteins. This means that if the query fails for the input GI
identifier, then the query will be retried for all other GI identifiers that belong to the same redundant group.
The BLAST protein neighbours were calculated using 0.01 maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>comment: </b>The neighbours are stored in a list of lists of structures which contain the total number of neighbours, list of GI identifiers, and a
list of E-values<br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers, memory address for the results (pointer to FLinkSetList2), float E-value
cutoff<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundNeighboursOfNeighboursList(ValNodePtr pvngilist, FLinkSetList2Ptr PNTR pAllNeighboursList, FloatHi evalue));<br>

<br><br><b>C++</b><br>

<b>comment: </b>The neighbours are stored in a list of lists of structures which contain the total number of neighbours, list of GI identifiers, and a
list of E-values<br>
<b>arguments: </b>reference to an STL list of integer GI identifiers, reference for the result (CFLink_set_List3), float E-value cutoff<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundNeighboursOfNeighboursList(list<int>& stlGi, CFLink_set_List3&,  float evalue);<br>
<a href=apifunctslist.html#SHoundNeighboursOfNeighboursList>list of functions</a><br><br>
<br><h2><a name=SHoundNumNeighboursInDB>SHoundNumNeighboursInDB</a></h2>

<br><b>description: </b>Gets a total number of neighbours in the database. The BLAST protein neighbours were calculated using 0.01
maximum E-value cutoff.<br>


<br><br><b>C</b><br>
<b>arguments: </b>memory address for the results (integer)<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>

<b>prototype: </b>SLRI_ERR LIBCALL SHoundNumNeighboursInDB (Int4 PNTR pnum);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference for the result (integer)<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundNumNeighboursInDB(int& pnum);<br>
<a href=apifunctslist.html#SHoundNumNeighboursInDB>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_1>COMPLETE GENOME ANALYSIS</a></h1><br><br>These functions return information concerning completely sequenced genomes that
are present in SeqHound.<br><br>



<br><h2><a name=SHound3DListFromTaxID>SHound3DListFromTaxID</a></h2>
<br><b>description: </b>Returns a list of proteins with 3-D structure for a complete organism.  The function uses redundancy information
 but no neighbour information<br>


<br><br><b>C</b><br>
<b>comment: </b>The results are stored in a structure which contains the total number of 3-D structures, list of GI identifiers, and a list of
structural MMDB identifiers<br>
<b>arguments: </b>integer taxonomy identifier, memory address for the results (pointer to ILinkSet)<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHound3DListFromTaxID(Int4 TaxID, ILinkSetPtr PNTR p3DList);<br>
<br><br><b>C++</b><br>

<b>comment: </b>The results are stored in a structure which contains the total number of 3-D structures, list of GI identifiers, and a list of
structural MMDB identifiers<br>
<b>arguments: </b>integer taxonomy identifier and reference for the result (CILink_set)<br>
<b>return: </b>integer error code:
<br>SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred
<br>SEQHOUND_NULL if the value was not found in the database
<br>WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHound3DListFromTaxID(int taxid, CILink_set& p3DNeighbours);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>taxonomy identifier<br>
<b>return: </b>comma delimited list of GI identifiers<br>
<b>example: </b>SHound3DListFromTaxID(2097);<br>

<a href=apifunctslist.html#SHound3DListFromTaxID>list of functions</a><br><br>

<br><h2><a name=SHoundAllGenomesWithNumProteins>SHoundAllGenomesWithNumProteins</a></h2>
<br><b>description: </b>Retrieves summary for complete genomes and their protein count.<br>


<br><br><b>C</b><br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The results are stored in a structure which contains the total number of genomes, list of taxonomy identifiers, and a list of protein
counts<br>
<b>arguments: </b>memory address for the result (pointer to ILinkSet)<br>
<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>

<b>prototype: </b>SLRI_ERR LIBCALL SHoundAllGenomesWithNumProteins(ILinkSetPtr PNTR pAllGenomes);<br>
<br><br><b>C++</b><br>
<b>comment: </b>The results are stored in a structure which contains the total number of genomes, list of taxonomy identifiers, and a list of protein
counts<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>reference for the result (CILink_set)<br>

<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundAllGenomesWithNumProteins(CILink_set& pAllGenomes);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>none<br>

<b>return: </b>a list of taxonomy identifiers and their associated number of proteins<br>
<b>example: </b>@list = SHoundAllGenomesWithNumProteins();<br>
<a href=apifunctslist.html#SHoundAllGenomesWithNumProteins>list of functions</a><br><br>

<br><h2><a name=SHoundAllGenomesWithScientificNames>SHoundAllGenomesWithScientificNames</a></h2>

<br><b>description: </b>Retrieves all complete genomes from SeqHound and their scientific names.<br>


<br><br><b>C</b><br>
<b>comment: </b>The results are stored in a structure which contains the total number of genomes, list of taxonomy identifiers, and a list of taxonomy
names<br>
<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call).  When the function call is completed, the memory
pointed to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>arguments: </b>memory address for the result (pointer to CLinkSet)<br>

<b>return: </b>integer error code; SLRI_SUCCESS for success or SLRI_FAIL<br>
<b>prototype: </b>SLRI_ERR SHoundAllGenomesWithScientificNames(CLinkSetPtr PNTR pAllGenomes);<br>
<br><br><b>C++</b><br>

<b>comment: </b>The API takes the memory address of a pointer as one argument. Please make sure that NO memory is allocated to the structure pointed to
by the pointer (e.g. initialize the pointer to NULL before passing it to the SeqHound API call). When the function call is completed, the memory pointed
 to by the pointer as a result of the API call should be freed to avoid memory leak.<br>

<b>comment: </b>The results are stored in a structure which contains the total number of genomes, list of taxonomy identifiers, and a list of taxonomy
names<br>
<b>arguments: </b>reference for the result (CCLink_set)<br>
<b>return: </b>integer error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the database,
WWWGETFILE_ERROR if a transmission error occurred<br>

<b>prototype: </b>int SHoundAllGenomesWithScientificNames(CCLink_set& pAllGenomes);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>none<br>

<b>return: </b>a list of taxonomy identifiers and their associated scientific names<br>
<b>example: </b>@list = SHoundAllGenomesWithScientificNames();<br>
<a href=apifunctslist.html#SHoundAllGenomesWithScientificNames>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_4>FUNCTIONAL ANNOTATION</a></h1><br><br>These functions retrieve functional annotation related to sequence records in
SeqHound.  This annotation includes associated  identifiers from the Gene Ontology (GO), Online Inheritance in Man (OMIM), NCBI's Conserved Domain Database
 (CDD) and LocusLink.<br><br>





<br><h2><a name=SHoundCDDIDFromGi>SHoundCDDIDFromGi</a></h2>

<br><b>description: </b>Fetches domains from Conserved Domain Database (CDD) as determined by Reverse Position Specific BLAST on a given
 sequence.<br>
<b>comment: </b>Domain information returned by this function was originally retrieved for proteins found in NCBI's LocusLink database.
If the query protein GI identifier is not used by the LocusLink record then no information will be returned.  The query protein GI
identifier could be used to first retrieve a list of redundant (identical) sequence GI identifiers using <a
href=apifunctsdet.html#SHoundRedundantGroup > SHoundRedundantGroup </a> and then using these returned protein GI identifiers to query the
 LocusLink data.

For more conserved domain information (for all proteins found in NCBI's nr dataset) see API functions under <a
href=apifunctsdet.html#SECTIONID_7> RPS BLAST Domains.</a><br>
<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier (must be protein GI identifier)<br>
<b>return: </b>pointer to a ValNode linked list of string CDD identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundCDDIDFromGi(Int4 gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier (must be protein GI identifier)<br>

<b>return: </b>pointer to an STL list of string CDD identifiers or to an empty list<br>
<b>prototype: </b>list<string> *SHoundCDDIDFromGi(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier (must be protein GI identifier  e.g. 4502501)<br>
<b>return: </b>comma delimited list of CDDIDs (e.g.COG2373, pfam00207,pfam01821,pfam01835) or zero if failure<br>
<b>example: </b>SHoundCDDIDFromGi(4557225);<br>
<a href=apifunctslist.html#SHoundCDDIDFromGi>list of functions</a><br><br>













<br><h2><a name=SHoundCDDIDFromGiList>SHoundCDDIDFromGiList</a></h2>

<br><b>description: </b>Fetches domains from Conserved Domain Database (CDD) as determined by Reverse Position Specific BLAST on a list
of sequences.<br>
<b>comment: </b>Domain information returned by this function was originally retrieved for proteins found in NCBI's LocusLink database.
If the query protein GI identifier is not used by the LocusLink record then no information will be returned.  The query protein GI
identifier could be used to first retrieve a list of redundant (identical) sequence GI identifiers using <a
href=apifunctsdet.html#SHoundRedundantGroup > SHoundRedundantGroup </a> and then using these returned protein GI identifiers to query the
 LocusLink data.

For more conserved domain information (for all proteins found in NCBI's nr dataset) see API functions under <a
href=apifunctsdet.html#SECTIONID_7> RPS BLAST Domains.</a>

The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers (must be protein GI identifiers)<br>

<b>return: </b>pointer to a ValNode linked list of string CDD identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundCDDIDFromGiList(ValNodePtr vnpgi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer GI identifiers (must be protein GI identifiers)<br>
<b>return: </b>pointer to a ValNode linked list of string CDD identifiers or NULL<br>
<b>prototype: </b>list<string> *SHoundCDDIDFromGiList(list<int>& stlGi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited GI identifiers (must be protein GI identifiers e.g. 4502501,4501843)<br>
<b>return: </b>comma delimited list of CDDIDs or zero if failure<br>

<b>example: </b>SHoundCDDIDFromGiList("4501841,4557225");<br>
<a href=apifunctslist.html#SHoundCDDIDFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundCDDIDFromLLID>SHoundCDDIDFromLLID</a></h2>
<br><b>description: </b>Fetches all Conserved Domain Database (CDD) IDs for a given LocusLink ID (LLID)<br>


<br><br><b>PERL</b><br>

<b>arguments: </b>Locus Link ID (LLID)<br>
<b>return: </b>list of CDDIDs or zero if failure<br>
<b>example: </b>SHoundCDDIDFromLLID(1);<br>

<a href=apifunctslist.html#SHoundCDDIDFromLLID>list of functions</a><br><br>
<br><h2><a name=SHoundCDDScoreFromGi>SHoundCDDScoreFromGi</a></h2>

<br><b>description: </b>Fetches a score for Conserved Domain Database (CDD) domain assignment as determined by Reverse Position Specific
 BLAST.<br>
<b>comment: </b>Currently, this function does not return meaningful results because there are no evalues associated with the records.

Information returned by this function was originally retrieved for proteins found in NCBI's LocusLink database.  If the query protein GI
identifier is not used by the LocusLink record then no information will be returned.  The query protein GI identifier could be used to
first retrieve a list of redundant (identical) sequence GI identifiers using <a href=apifunctsdet.html#SHoundRedundantGroup >
SHoundRedundantGroup </a> and then using these returned protein GI identifiers to query the LocusLink data.

For more conserved domain information (for all proteins found in NCBI's nr dataset) see API functions under <a
href=apifunctsdet.html#SECTIONID_7> RPS BLAST Domains.</a><br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier and string CDD identifier (must be protein GI)<br>
<b>return: </b>float score, -1 or zero on error<br>
<b>prototype: </b>FloatHi SHoundCDDScoreFromGi(Int4 gi, CharPtr cddid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier (must be protein GI identifier) and string CDD identifier<br>
<b>return: </b>float score or an error code; SEQHOUND_ERROR  or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not found in the
database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>float SHoundCDDScoreFromGi(int Gi, string cddid);<br>

<a href=apifunctslist.html#SHoundCDDScoreFromGi>list of functions</a><br><br>
<br><h2><a name=SHoundGiFromCDDID>SHoundGiFromCDDID</a></h2>

<br><b>description: </b>Fetches all protein sequences carrying a domain from Conserved Domain Database (CDD) as determined by Reverse
Position Specific BLAST.  Uses information from NCBI's LocusLink database.  If the query CDD identifier is not used by LocusLink then no
 information will be returned.<br>

<br><br><b>C</b><br>

<b>arguments: </b>pointer to a string containing CDD identifier<br>
<b>return: </b>ValNode linked list of integer protein GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromCDDID(const CharPtr cddid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>string CDD identifier<br>
<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGiFromCDDID(string& cddid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>Conserved Domain Database ID (CDDID) (either Pfam or SMART e.g. pfam00202)<br>

<b>return: </b>comma delimited list of protein GI identifiers or zero if failure<br>
<b>example: </b>SHoundGiFromCDDID("pfam00664");<br>
<a href=apifunctslist.html#SHoundGiFromCDDID>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromCDDIDList>SHoundGiFromCDDIDList</a></h2>
<br><b>description: </b>Fetches all protein sequences carrying a list of domains from Conserved Domain Database (CDD) as determined by
Reverse Position Specific BLAST.  Uses information from NCBI's LocusLink database.  If the query CDD identifier is not used by LocusLink
 then no information will be returned.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of string CDD identifiers<br>

<b>return: </b>pointer to a ValNode linked list of integer protein GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromCDDIDList(ValNodePtr vnpcdd);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of string CDD identifiers<br>
<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFromCDDIDList(list<string>& stlcdd);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>a comma delimited Conserved Domain Database ID (CDDID) list (e.g. "pfam00202,pfam01835,pfam00079" )<br>
<b>return: </b>comma delimited list of protein GI identifiers or zero if failure<br>
<b>example: </b>SHoundGiFromCDDIDList("pfam00202,pfam01835,pfam00079,smart00231");<br>

<a href=apifunctslist.html#SHoundGiFromCDDIDList>list of functions</a><br><br>
<br><h2><a name=SHoundGiFromGOID>SHoundGiFromGOID</a></h2>

<br><b>description: </b>Fetches all protein sequences which were assigned a given Gene Ontology (GO) function, process or component.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GO identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromGOID(Int4 goid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFromGOID(int GOID);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GO identifier<br>
<b>return: </b>comma delimited list of GI identifiers or zero<br>

<b>example: </b>SHoundGiFromGOID(8320);<br>
<a href=apifunctslist.html#SHoundGiFromGOID>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromGOIDAndECode>SHoundGiFromGOIDAndECode</a></h2>
<br><b>description: </b>Gets GI identifiers from Gene Ontology ID (GOID) and evidence code (ECode)<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier and GO evidence code (CharPtr)<br>
<b>return: </b>pointer to a list of integer GIs or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGiFromGOIDAndECode(Int4 goid, CharPtr ecode);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier and GO evidence code<br>
<b>return: </b>list of integer Gis or NULL<br>

<b>prototype: </b>list<int> *SHoundGiFromGOIDAndECode(int goid, string ecode );<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GOID (e.g. 5554), ecode(e.g. ND)<br>

<b>return: </b>a list of comma delimited GI or zero if failure<br>
<b>example: </b>SHoundGiFromGOIDAndECode(5554, ND)<br>
<a href=apifunctslist.html#SHoundGiFromGOIDAndECode>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromGOIDList>SHoundGiFromGOIDList</a></h2>

<br><b>description: </b>Fetches all protein sequences which were assigned a list of Gene Ontology (GO) functions, processes or
components.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GO identifiers<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromGOIDList(ValNodePtr vnpgo);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer GO identifiers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFromGOIDList(list<int>& stlGo);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of GO identifiers<br>
<b>return: </b>comma delimited list of GI identifiers or zero<br>

<b>example: </b>SHoundGiFromGOIDList("8320,5737");<br>
<a href=apifunctslist.html#SHoundGiFromGOIDList>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromGOIDListAndECode>SHoundGiFromGOIDListAndECode</a></h2>
<br><b>description: </b>Gets GI identifiers from Gene Ontology ID (GOID) list and evidence code (ECode)<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier list and one GO evidence code<br>
<b>return: </b>pointer to a list of integer GIs (unique) or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGiFromGOIDListAndECode(ValNodePtr vnpgo, CharPtr ecode);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier list and one GO evidence code<br>
<b>return: </b>list of integer GO Ids or NULL<br>

<b>prototype: </b>list<int> *SHoundGiFromGOIDListAndECode(list<int>& stlGo, string ecode);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GOIDList (e.g. 5554,4), ecode(e.g. ND)<br>

<b>return: </b>a list of comma delimited GI or zero if failure<br>
<b>example: </b>SHoundGiFromGOIDListAndECode(5554,4, ND);<br>
<a href=apifunctslist.html#SHoundGiFromGOIDListAndECode>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromLLID>SHoundGiFromLLID</a></h2>

<br><b>description: </b>Fetches protein GI identifiers associated with NCBI's LocusLink ID (LLID)<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer LocusLink identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer protein GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGiFromLLID(Int4 llid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer LocusLink identifier<br>

<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFromLLID(int llid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>LocusLink ID (LLID) (e.g. 9)<br>
<b>return: </b>comma delimited list of protein GI identifiers or zero if failure<br>
<b>example: </b>SHoundGiFromLLID(9);<br>

<a href=apifunctslist.html#SHoundGiFromLLID>list of functions</a><br><br>
<br><h2><a name=SHoundGiFromLLIDList>SHoundGiFromLLIDList</a></h2>

<br><b>description: </b>Fetches protein GI identifiers associated with a list of NCBI's LocusLink IDs (LLID).<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer LocusLink identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer protein GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromLLIDList(ValNodePtr vnpll);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer LocusLink identifiers<br>
<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGiFromLLIDList(list<int>& stllid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of LLIDs (e.g. 2,9, 13)<br>
<b>return: </b>comma delimited list of protein GI identifiers (e.g.4557225,4557227,27754153) or zero if failure<br>
<b>example: </b>SHoundGiFromLLIDList("1,2,13");<br>

<a href=apifunctslist.html#SHoundGiFromLLIDList>list of functions</a><br><br>
<br><h2><a name=SHoundGiFromOMIM>SHoundGiFromOMIM</a></h2>

<br><b>description: </b>Fetches all protein GI identifiers associated with an entry in Online Mendelian Inheritance in Man (OMIM)
database.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer OMIM identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer protein GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGiFromOMIM(Int4 omimid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer OMIM identifier<br>
<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGiFromOMIM(int omimid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>OMIM ID (e.g. 137150 )<br>

<b>return: </b>comma delimited list of protein GI identifiers (e.g. 4501847) or zero if failure<br>
<b>example: </b>SHoundGiFromOMIM(103950);<br>
<a href=apifunctslist.html#SHoundGiFromOMIM>list of functions</a><br><br>

<br><h2><a name=SHoundGiFromOMIMList>SHoundGiFromOMIMList</a></h2>

<br><b>description: </b>Fetches all protein GI identifiers associated with a list of entries in Online Mendelian Inheritance in Man
(OMIM) database.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer OMIM identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer protein GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGiFromOMIMList(ValNodePtr vnpomim);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer OMIM identifiers<br>
<b>return: </b>pointer to an STL list of integer protein GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGiFromOMIMList(list<int>& stlomim);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited OMIM IDs  (e.g. 137150,103950,108345 )<br>
<b>return: </b>comma delimited list of protein GI identifiers (e.g.4501847,4557225) or zero if failure<br>

<b>example: </b>SHoundGiFromOMIMList("137150,103950,108345");<br>
<a href=apifunctslist.html#SHoundGiFromOMIMList>list of functions</a><br><br>

<br><h2><a name=SHoundGOECodeFromGiAndGOID>SHoundGOECodeFromGiAndGOID</a></h2>
<br><b>description: </b>Gets evidence code from GI identifier and Gene Ontology (GO) ID.<br>


<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier and integer GO identifier<br>
<b>return: </b>ValNodePtr  linked with a list of character GO evidence code (not unique) or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGOECodeFromGiAndGOID(Int4 Gi, Int4 goid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier and integer GO identifier<br>
<b>return: </b>list of string GO evidence codes or NULL<br>

<b>prototype: </b>list<string> *SHoundGOECodeFromGiAndGOID(int Gi, int goid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI (e.g. 21071030), GOID (e.g. 5554)<br>

<b>return: </b>a list of comma delimited Ecode or zero if failure<br>
<b>example: </b>SHoundGOECodeFromGiAndGOID(21071030, 5554);<br>
<a href=apifunctslist.html#SHoundGOECodeFromGiAndGOID>list of functions</a><br><br>

<br><h2><a name=SHoundGOIDFromGi>SHoundGOIDFromGi</a></h2>

<br><b>description: </b>Fetches all Gene Ontology (GO) terms assigned to a protein sequence.  An individual sequence can be referred to
by one or more process, function or component terms.<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGOIDFromGi(Int4 gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGOIDFromGi(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>
<b>return: </b>comma delimited list of GO identifiers or zero<br>

<b>example: </b>SHoundGOIDFromGi(15149484);<br>
<a href=apifunctslist.html#SHoundGOIDFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundGOIDFromGiList>SHoundGOIDFromGiList</a></h2>
<br><b>description: </b>Fetches all Gene Ontology (GO) terms assigned to a list of protein sequences.  An individual sequence can be
referred to by one or more process, function or component terms.<br>
<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGOIDFromGiList(ValNodePtr vnpgi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGOIDFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of GI identifiers<br>
<b>return: </b>comma delimited list of GO identifiers or zero<br>
<b>example: </b>SHoundGOIDFromGiList("15149484,6912624");<br>

<a href=apifunctslist.html#SHoundGOIDFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundGOIDFromLLID>SHoundGOIDFromLLID</a></h2>

<br><b>description: </b>Fetches all Gene Ontology (GO) IDs for a given LocusLink ID (LLID)<br>


<br><br><b>PERL</b><br>
<b>arguments: </b>Locus Link ID (LLID, e.g. 1)<br>

<b>return: </b>comma delimited list of GOIDs or zero if failure<br>
<b>example: </b>SHoundGOIDFromLLID(1);<br>
<a href=apifunctslist.html#SHoundGOIDFromLLID>list of functions</a><br><br>

<br><h2><a name=SHoundGOIDFromRedundantGi>SHoundGOIDFromRedundantGi</a></h2>

<br><b>description: </b>Fetches all Gene Ontology (GO) term identifiers assigned to a protein sequence.  Uses redundancy information for
 the query GI identifier.  This means that if the query fails for the input GI identifier, then the query will be retried for all other
GI identifiers that belong to the same redundant group.  An individual sequence can be referred to by one or more a process, function or
 component terms.<br>

<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>

<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGOIDFromRedundantGi(Int4 gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGOIDFromRedundantGi(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier (e.g. 21071030)<br>
<b>return: </b>comma delimited list of GO identifiers or or zero if failure<br>

<b>example: </b>SHoundGOIDFromRedundantGi(15149484);<br>
<a href=apifunctslist.html#SHoundGOIDFromRedundantGi>list of functions</a><br><br>

<br><h2><a name=SHoundGOIDFromRedundantGiList>SHoundGOIDFromRedundantGiList</a></h2>
<br><b>description: </b>Fetches all Gene Ontology (GO) term identifiers assigned to a list of protein sequences.  Uses redundancy
information for the query GI identifier.  This means that if the query fails for the input GI identifier, then the query will be retried
 for all other GI identifiers that belong to the same redundant group.  An individual sequence can be referred to by one or more a
process, function or component terms.<br>

<b>comment: </b>The order in the lists is not maintained<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGOIDFromRedundantGiList(ValNodePtr vnpgi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>

<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGOIDFromRedundantGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>comma delimited list of GI identifiers (e.g. "21071030,4586891")<br>
<b>return: </b>comma delimited list of GO identifiers or zero if failure<br>
<b>example: </b>SHoundGOIDFromRedundantGiList("15149484,6912624");<br>
<a href=apifunctslist.html#SHoundGOIDFromRedundantGiList>list of functions</a><br><br>
<br><h2><a name=SHoundGOPMIDFromGiAndGOID>SHoundGOPMIDFromGiAndGOID</a></h2>

<br><b>description: </b>Gets PMID list from GI identifier and Gene Ontology ID (GOID)<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier and integer GO identifier<br>

<b>return: </b>ValNodePtr linked with a list of integer PMIDs (not unique) or NULL<br>
<b>prototype: </b>ValNodePtr  SHoundGOPMIDFromGiAndGOID(Int4 Gi, Int4 goid);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier and integer GO identifier<br>
<b>return: </b>list of integer PMIDs or NULL<br>
<b>prototype: </b>list<int> *SHoundGOPMIDFromGiAndGOID(int Gi, int goid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI (e.g. 21071030), GOID (e.g. 5554)<br>
<b>return: </b>a list of comma delimited PMID or zero if failure<br>

<b>example: </b>SHoundGOPMIDFromGiAndGOID(21071030, 5554)<br>
<a href=apifunctslist.html#SHoundGOPMIDFromGiAndGOID>list of functions</a><br><br>

<br><h2><a name=SHoundLLIDFromCDDID>SHoundLLIDFromCDDID</a></h2>
<br><b>description: </b>Fetches LocusLink IDs (LLID) for a given Conserved Domain Database (CDD) ID<br>


<br><br><b>PERL</b><br>

<b>arguments: </b>Conserved Domain ID<br>
<b>return: </b>comma delimited list of LLIDs or zero if failure<br>
<b>example: </b>SHoundLLIDFromCDDID("smart00408");<br>

<a href=apifunctslist.html#SHoundLLIDFromCDDID>list of functions</a><br><br>
<br><h2><a name=SHoundLLIDFromGi>SHoundLLIDFromGi</a></h2>

<br><b>description: </b>Fetches LocusLink IDs (LLID) for a given protein sequence.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier (must be protein GI identifier)<br>

<b>return: </b>integer LocusLink identifier , -1  or zero on error<br>
<b>prototype: </b>Int4 SHoundLLIDFromGi(Int4 gi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>integer GI identifier (must be protein GI identifier)<br>
<b>return: </b>integer LocusLink identifier or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was
not found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundLLIDFromGi(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier (must be protein GI identifier e.g. 4501843)<br>
<b>return: </b>LLID (e.g. 12) or zero if failure<br>
<b>example: </b>SHoundLLIDFromGi(4501843);<br>

<a href=apifunctslist.html#SHoundLLIDFromGi>list of functions</a><br><br>




<br><h2><a name=SHoundLLIDFromGiList>SHoundLLIDFromGiList</a></h2>

<br><b>description: </b>Fetches LocusLink IDs (LLID) associated with a list of protein GI identifiers.<br>

<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers (must be protein GI identifiers)<br>

<b>return: </b>pointer to a ValNode linked list of integer LocusLink identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundLLIDFromGiList(ValNodePtr vnpgi);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of integer GI identifiers (must be protein GI identifiers)<br>
<b>return: </b>pointer to an STL list of integer LocusLink identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundLLIDFromGiList(list<int>& stlGi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of GIs (must be protein GI identifiers e.g. 4501841,4557225)<br>
<b>return: </b>comma delimited list of LLIDs (e.g. 2, 16) or zero if failure<br>

<b>example: </b>SHoundLLIDFromGiList("4501841,4557225");<br>
<a href=apifunctslist.html#SHoundLLIDFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundLLIDFromGOIDAndECode>SHoundLLIDFromGOIDAndECode</a></h2>
<br><b>description: </b>Fetches LocusLink IDs (LLID) for a given Gene Ontology ID (GOID) and evidence code (ECode)<br>



<br><br><b>PERL</b><br>
<b>arguments: </b>GOID
<br>GO evidence code (e.g. "IEA")<br>
<b>return: </b>comma delimited list of LLIDs or zero if failure<br>

<b>example: </b>SHoundLLIDFromGOIDAndECode(6810, "IEA");<br>
<a href=apifunctslist.html#SHoundLLIDFromGOIDAndECode>list of functions</a><br><br>

<br><h2><a name=SHoundLLIDFromOMIM>SHoundLLIDFromOMIM</a></h2>
<br><b>description: </b>Fetches LocusLink IDs (LLID) for a given Online Mendelian Inheritance in Man (OMIM) ID.<br>



<br><br><b>PERL</b><br>
<b>arguments: </b>OMIM ID<br>
<b>return: </b>comma delimited list of LLIDs or zero if failure<br>

<b>example: </b>$seqhound->SHoundLLIDFromOMIM(103950);<br>
<a href=apifunctslist.html#SHoundLLIDFromOMIM>list of functions</a><br><br>

<br><h2><a name=SHoundLocusFromGi>SHoundLocusFromGi</a></h2>
<br><b>description: </b>Fetches a locus assignment for a protein sequence as found in NCBI's LocusLink database.<br>



<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier (must be protein GI identifier)<br>
<b>return: </b>pointer to a string containing a locus or NULL<br>

<b>prototype: </b>CharPtr SHoundLocusFromGi(Int4 gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier  (must be protein GI identifier)<br>

<b>return: </b>string containing a locus or an empty string<br>
<b>prototype: </b>string SHoundLocusFromGi(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier (must be protein GI identifier e.g. 51036689)<br>
<b>return: </b>locus (e.g. 14q32.1) or zero if failure<br>

<b>example: </b>SHoundLocusFromGi(51036689);<br>
<a href=apifunctslist.html#SHoundLocusFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundOMIMFromGi>SHoundOMIMFromGi</a></h2>
<br><b>description: </b>Fetches Online Mendelian Inheritance in Man (OMIM) database identifiers associated with a protein GI
identifier.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier  (must be protein GI identifier)<br>

<b>return: </b>pointer to a ValNode linked list of integer OMIM identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundOMIMFromGi(Int4 gi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier  (must be protein GI identifier)<br>

<b>return: </b>pointer to an STL list of integer OMIM identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundOMIMFromGi(int Gi);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GI identifier  (must be protein GI identifier e.g. 4502501)<br>
<b>return: </b>comma delimited list of OMIM IDs (e.g. 120820) or zero if failure<br>
<b>example: </b>SHoundOMIMFromGi(4505335);<br>

<a href=apifunctslist.html#SHoundOMIMFromGi>list of functions</a><br><br>
<br><h2><a name=SHoundOMIMFromGiList>SHoundOMIMFromGiList</a></h2>

<br><b>description: </b>Fetches Online Mendelian Inheritance in Man (OMIM) database identifiers associated with a list of protein GI
identifiers.<br>
<b>comment: </b>The order in the lists is not maintained<br>
<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers (must be protein GI identifiers)<br>
<b>return: </b>pointer to a ValNode linked list of integer OMIM identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundOMIMFromGiList(ValNodePtr vnpgi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers (must be protein GI identifiers)<br>
<b>return: </b>pointer to an STL list of integer OMIM identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundOMIMFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of GI identifiers (must be protein GI identifiers e.g. 4502501,4501843)<br>

<b>return: </b>comma delimited list of OMIM IDs (e.g. 107280,120820) or zero if failure<br>
<b>example: </b>SHoundOMIMFromGiList("4501841,4557225");<br>
<a href=apifunctslist.html#SHoundOMIMFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundOMIMFromLLID>SHoundOMIMFromLLID</a></h2>

<br><b>description: </b>Fetches Online Mendelian Inheritance in Man (OMIM) IDs for a given LocusLink ID (LLID)<br>


<br><br><b>PERL</b><br>
<b>arguments: </b>Locus Link ID (LLID)<br>
<b>return: </b>OMIM ID or zero if failure<br>

<b>example: </b>SHoundOMIMFromLLID(1);<br>
<a href=apifunctslist.html#SHoundOMIMFromLLID>list of functions</a><br><br>

<br><h2><a name=SHoundProteinReportSetDescription>SHoundProteinReportSetDescription</a></h2>
<br><b>description: </b><br>





<a href=apifunctslist.html#SHoundProteinReportSetDescription>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_5>GO HIERARCHY</a></h1><br><br>These functions allow the programmer to traverse the Gene Ontology directed acyclic graph.
See http://www.geneontology.org/ for more information on this data structure.<br><br>



<br><h2><a name=SHoundGODBGetAllAncestors>SHoundGODBGetAllAncestors</a></h2>

<br><b>description: </b>This function operates on Gene Ontology (GO) vocabulary graphs.  It retrieves a list of all processes, functions
 or components situated above a given GO identifier in the graphs.<br>




<br><br><b>C</b><br>
<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGODBGetAllAncestors(Int4 goid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>

<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGODBGetAllAncestors(int goid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GO identifier<br>
<b>return: </b>comma delimited list of GO identifiers or zero<br>
<b>example: </b>SHoundGODBGetAllAncestors(7596);<br>
<a href=apifunctslist.html#SHoundGODBGetAllAncestors>list of functions</a><br><br>

<br><h2><a name=SHoundGODBGetAllChildren>SHoundGODBGetAllChildren</a></h2>

<br><b>description: </b>Operates on Gene Ontology (GO) vocabulary graphs.  Retrieves a list all of processes, functions or components
situated below a given GO identifier in the graphs.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGODBGetAllChildren(Int4 goid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGODBGetAllChildren(int goid);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GO identifier<br>

<b>return: </b>comma delimited list of GO identifiers or zero<br>
<b>example: </b>SHoundGODBGetAllChildren(6886);<br>
<a href=apifunctslist.html#SHoundGODBGetAllChildren>list of functions</a><br><br>

<br><h2><a name=SHoundGODBGetChildrenOf>SHoundGODBGetChildrenOf</a></h2>

<br><b>description: </b>Operates on Gene Ontology (GO) vocabulary graphs.  Retrieves a list of processes, functions or components
situated directly below a given GO identifier in the graphs.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGODBGetChildrenOf(Int4 goid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGODBGetChildrenOf(int goid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GO identifier<br>
<b>return: </b>comma delimited list of GO identifiers or zero<br>

<b>example: </b>SHoundGODBGetChildrenOf(7596);<br>
<a href=apifunctslist.html#SHoundGODBGetChildrenOf>list of functions</a><br><br>

<br><h2><a name=SHoundGODBGetClassification>SHoundGODBGetClassification</a></h2>
<br><b>description: </b>Operates on Gene Ontology (GO) vocabulary graphs.  Reports if a given GO identifier describes a cellular
process, a cellular function or a cellular component.<br>

<b>comment: </b>GO_MOL_FUN refers to a function
GO_BIO_PRO refers to a process
GO_CELL_COM refers to a component<br>
<br><br><b>C</b><br>
<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a string containing the category name or NULL<br>

<b>prototype: </b>CharPtr SHoundGODBGetClassification(Int4 goid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>

<b>return: </b>string containing the category name or an empty string<br>
<b>prototype: </b>string SHoundGODBGetClassification(int goid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GO identifier<br>
<b>return: </b>string containing the category name or zero<br>
<b>example: </b>SHoundGODBGetClassification(4866);<br>
<a href=apifunctslist.html#SHoundGODBGetClassification>list of functions</a><br><br>

<br><h2><a name=SHoundGODBGetNameByID>SHoundGODBGetNameByID</a></h2>

<br><b>description: </b>Operates on Gene Ontology (GO) vocabulary graphs.  Retrieves a name of a process, a function or a component for
a given GO identifier.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a string containing containing the ontology name or NULL<br>

<b>prototype: </b>CharPtr SHoundGODBGetNameByID(Int4 goid);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>

<b>return: </b>string containing the ontology name or an empty string<br>
<b>prototype: </b>string SHoundGODBGetNameByID(int goid);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>GO identifier<br>
<b>return: </b>string containing the ontology name or zero<br>
<b>example: </b>SHoundGODBGetNameByID(4866);<br>

<a href=apifunctslist.html#SHoundGODBGetNameByID>list of functions</a><br><br>
<br><h2><a name=SHoundGODBGetParentOf>SHoundGODBGetParentOf</a></h2>

<br><b>description: </b>Operates on Gene Ontology (GO) vocabulary graphs.  Retrieves a list of processes, functions or components
situated directly above a given GO identifier in the graphs.<br>
<b>comment: </b>due to the logic of the GO hierarchy graphs, it is possible that a GO identifier will have more than one parent<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGODBGetParentOf(Int4 goid);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GO identifier<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGODBGetParentOf(int goid);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GO identifier<br>
<b>return: </b>comma delimited list of GO identifiers or zero<br>

<b>example: </b>SHoundGODBGetParentOf(7596);<br>
<a href=apifunctslist.html#SHoundGODBGetParentOf>list of functions</a><br><br>

<br><h2><a name=SHoundGODBGetRecordByReference>SHoundGODBGetRecordByReference</a></h2>
<br><b>description: </b>Gets a list of  Gene Ontology (GO) IDs with a specified GO reference type.<br>


<br><br><b>C</b><br>

<b>arguments: </b>a reference type for GO module (e.g. EC)<br>
<b>return: </b>pointer to a ValNode linked list of integer GO identifiers or NULL<br>
<b>prototype: </b>ValNodePtr   SHoundGODBGetRecordByReference(CharPtr refType)<br>

<br><br><b>C++</b><br>
<b>arguments: </b>a reference type for GO module (e.g. EC)<br>
<b>return: </b>pointer to an STL list of integer GO identifiers or to an empty list<br>

<b>prototype: </b>list<int> SHoundGODBGetRecordByReference(string refType)<br>
<br><br><b>PERL</b><br>
<b>comment: </b>Return list is sorted and unique<br>

<b>arguments: </b>a reference type for GO module (e.g. EC)<br>
<b>return: </b>a comma delimited list of records (e.g. 9,10,16,26,30,33,34......) or zero if failure<br>
<b>example: </b>SHoundGODBGetRecordByReference("EC");<br>
<a href=apifunctslist.html#SHoundGODBGetRecordByReference>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_7>RPS BLAST DOMAINS</a></h1><br><br>This group of functions is used to correlate conserved domains with protein sequence
records.  Conserved domains are precomputed for a non-redundant set of proteins in SeqHound using RPS BLAST and the Conserved Domain Database (CDD) from
the NCBI.<br><br>



<br><h2><a name=SHoundGetDomainIdFromLabel>SHoundGetDomainIdFromLabel</a></h2>

<br><b>description: </b>Returns one or more Conserved Domain Database (CDD) identifiers given a short non-unique label. The  labels are
preferred amongst the scientific community.<br>


<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing short label<br>
<b>return: </b>pointer to a ValNode linked list of string CDD identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetDomainIdFromLabel(CharPtr label);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>string containing short label<br>
<b>return: </b>pointer to an STL list of string CDD identifiers or to an empty list<br>

<b>prototype: </b>list<string> *SHoundGetDomainIdFromLabel(string label);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>short label<br>

<b>return: </b>comma delimited list of CDD identifiers<br>
<b>example: </b>SHoundGetDomainIdFromLabel("COLFI");<br>
<a href=apifunctslist.html#SHoundGetDomainIdFromLabel>list of functions</a><br><br>

<br><h2><a name=SHoundGetDomainLabelFromDomainId>SHoundGetDomainLabelFromDomainId</a></h2>

<br><b>description: </b>Returns a short non-unique label given a domain for a Conserved Domain Database (CDD). The  labels are preferred
 amongst the scientific community.<br>

<br><br><b>C</b><br>

<b>arguments: </b>pointer to a string containing CDD identifier<br>
<b>return: </b>pointer to a string containing short label or NULL<br>
<b>prototype: </b>CharPtr  SHoundGetDomainLabelFromDomainId(CharPtr accession);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>string CDD identifier<br>
<b>return: </b>string containing short label or an empty string<br>
<b>prototype: </b>string SHoundGetDomainLabelFromDomainId(string domain);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>CDD identifier<br>
<b>return: </b>short label<br>

<b>example: </b>SHoundGetDomainLabelFromDomainId(smart00038);<br>
<a href=apifunctslist.html#SHoundGetDomainLabelFromDomainId>list of functions</a><br><br>








<br><h2><a name=SHoundGetDomainsFromGi>SHoundGetDomainsFromGi</a></h2>

<br><b>description: </b>Fetches information about domains from the Conserved Domain Database (CDD) as assigned by Reverse Position
Specific BLAST to a given protein sequence.  Uses redundancy information for the query proteins.  This means that if the query fails for
 the input GI identifier, then the query will be retried for all other GI identifiers that belong to the same redundant group.<br>

<b>comment: </b>The returning structure contains CDD domain identifier, E-value, position, length of the alignment, N and C terminal
residues missing when compared to the consensus domain and the total number of domains on a protein.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>linked list of StRpsdb structures or NULL<br>
<b>prototype: </b>StRpsdbPtr SHoundGetDomainsFromGi(Int4 gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>linked list of CStRpsdb structures or NULL<br>

<b>prototype: </b>CStRpsdb *SHoundGetDomainsFromGi(int Gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>protein GI identifier (e.g. 4557225)<br>
<b>return: </b>linked list of StRpsdb structures in a parseable form or zero if failure<br>

<b>example: </b>SHoundGetDomainsFromGi(4557225);<br>
<a href=apifunctslist.html#SHoundGetDomainsFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundGetDomainsFromGiListWithEvalue>SHoundGetDomainsFromGiListWithEvalue</a></h2>
<br><b>description: </b>Fetches information about domains from the Conserved Domain Database (CDD) as assigned by Reverse Position
Specific BLAST to a given protein sequence.  This function does not use redundant group information yet.  The function uses an E-value
cutoff for reporting results.<br>


<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list  of integer GI identifiers and a float E-value cutoff<br>

<b>return: </b>linked list of CStRpsdb structures or NULL<br>
<b>prototype: </b>StRpsdbPtr  SHoundGetDomainsFromGiListWithEvalue(ValNodePtr pvnGis, FloatHi cutoff);<br>
<a href=apifunctslist.html#SHoundGetDomainsFromGiListWithEvalue>list of functions</a><br><br>

<br><h2><a name=SHoundGetDomainsFromGiWithEvalue>SHoundGetDomainsFromGiWithEvalue</a></h2>
<br><b>description: </b>Fetches information about domains from the Conserved Domain Database (CDD) as assigned by Reverse Position
Specific BLAST to a given protein sequence.  Uses redundancy information for the query proteins.  This means that if the query fails for
 the input GI identifier, then the query will be retried for all other GI identifiers that belong to the same redundant group.  The
function uses an E-value cutoff for reporting results.<br>

<b>comment: </b>The returning structure contains CDD domain identifier, E-value, position, length of the alignment, N and C terminal
residues missing when compared to the consensus domain and the total number of domains on a protein<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier and a float E-value cutoff<br>
<b>return: </b>linked list of StRpsdb structures or NULL<br>

<b>prototype: </b>StRpsdbPtr SHoundGetDomainsFromGiWithEvalue(Int4 gi, FloatHi cutoff);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier and a float E-value cutoff<br>
<b>return: </b>linked list of CStRpsdb structures or NULL<br>

<b>prototype: </b>CStRpsdb *SHoundGetDomainsFromGiWithEvalue(int Gi, float cutoff);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>protein GI identifier (e.g. 6322015)
<br>evalue cutoff  (e.g. 0.5)<br>
<b>return: </b>linked list of StRpsdb structures in a parseable form or zero if failure<br>

<b>example: </b>SHoundGetDomainsFromGiWithEvalue(4557225,0.001);<br>
<a href=apifunctslist.html#SHoundGetDomainsFromGiWithEvalue>list of functions</a><br><br>

<br><h2><a name=SHoundGetFilteredDomainsFromGiWithEvalue>SHoundGetFilteredDomainsFromGiWithEvalue</a></h2>
<br><b>description: </b><br>





<a href=apifunctslist.html#SHoundGetFilteredDomainsFromGiWithEvalue>list of functions</a><br><br>

<br><h2><a name=SHoundGetGisByDomainId>SHoundGetGisByDomainId</a></h2>
<br><b>description: </b>Fetches protein sequences on which a domain from the Conserved Domain Database (CDD) was identified by Reverse
Position Specific BLAST.<br>


<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing CDD identifier<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetGisByDomainId(CharPtr domain_name);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>string containing CDD identifier<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGetGisByDomainId(string domain);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>CDD identifier<br>
<b>return: </b>comma delimited list of GI identifiers<br>
<b>example: </b>SHoundGetGisByDomainId("smart00038");<br>

<a href=apifunctslist.html#SHoundGetGisByDomainId>list of functions</a><br><br>
<br><h2><a name=SHoundGetGisByDomainIdAndEvalue>SHoundGetGisByDomainIdAndEvalue</a></h2>

<br><b>description: </b>Fetches protein sequences on which a domain from the Conserved Domain Database (CDD) was identified by Reverse
Position Specific BLAST. The function uses an E-value cutoff for reporting results.<br>


<br><br><b>C</b><br>

<b>arguments: </b>pointer to a string containing CDD identifier and a float E-value cutoff<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundGetGisByDomainIdAndEvalue(CharPtr domain_id, FloatHi cutoff);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>string containing CDD identifier and a float E-value cutoff<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundGetGisByDomainIdAndEvalue(string domain, float cutoff);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>CDD identifier and E-value cutoff<br>
<b>return: </b>comma delimited list of GI identifiers<br>

<b>example: </b>SHoundGetGisByDomainId("smart00038",0.001);<br>
<a href=apifunctslist.html#SHoundGetGisByDomainIdAndEvalue>list of functions</a><br><br>
<br><h2><a name=SHoundGetGisByNumberOfDomains>SHoundGetGisByNumberOfDomains</a></h2>

<br><b>description: </b>Fetches all sequences with a specified number of domains identified by Reverse Position Specific BLAST using
Conserved Domain Database set of domains.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer number of domains<br>
<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>

<b>prototype: </b>ValNodePtr SHoundGetGisByNumberOfDomains(Int4 numdom);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>integer number of domains<br>

<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>
<b>prototype: </b>list<int> *SHoundGetGisByNumberOfDomains(int numdom);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>number of domains<br>
<b>return: </b>comma delimited list of GI identifiers<br>
<b>example: </b>SHoundGetGisByNumberOfDomains(6);<br>
<a href=apifunctslist.html#SHoundGetGisByNumberOfDomains>list of functions</a><br><br>

<br><br><h1><a name=SECTIONID_30>DEPRECATED FUNCTIONS</a></h1><br><br>The functions  listed in this section have been deprecated and may be replaced by new
 functions that may have different parameters and/or return types.   Functions are listed here for historical purposes only.  The description of each
function may list a comparable new function that can be used instead.  While deprecated functions will be supported, developers should use the new function
  listed going forward if at all possible.  If the function has not been written for your language of choice (see the function tracker at
http://www.blueprint.org/seqhound/apifunctsstatus.html), you may request that the function be written by sending an email to seqhound@blueprint.org.  This
will help us to direct our development efforts.  Once the versions of the new function (that replaces a deprecated function) have been written into the
remote Java, Perl, C and C++ remote API's we may consider removing support for these calls (with ample warning and in consideration of feedback).  At this
time, these functions would be moved to a section entitled Unsupported Functions.<br><br>















<br><h2><a name=SHoundAccFromGi>SHoundAccFromGi</a></h2>

<br><b>description: </b>Converts a GI identifier to an NCBI accession number.  This function name has been deprecated and should be
replaced with SHoundGBAccFromGi.<br>
<b>comment: </b>Sequences from the PIR or PDB databases will return "n/a" for this function since they do not have an
NCBI accession.  Instead, use SHoundGetDefline to retrieve the accession for these sequences.<br>

<br><br><b>C</b><br>

<b>arguments: </b>integer GI identifier<br>
<b>return: </b>pointer to a string containing accession number or NULL on error<br>
<b>prototype: </b>CharPtr SHoundAccFromGi(Int4 gi);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>string containing accession number or an empty string<br>
<b>prototype: </b>string SHoundAccFromGi(int Gi);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>
<b>return: </b>accession number or zero<br>

<b>example: </b>SHoundAccFromGi(435);<br>
<a href=apifunctslist.html#SHoundAccFromGi>list of functions</a><br><br>

<br><h2><a name=SHoundAccFromGiList>SHoundAccFromGiList</a></h2>
<br><b>description: </b>Converts a list of GI identifier to a list of  NCBI accession numbers.  This function has been deprecated.  Use
SHoundGBAccFromGiKeyedList instead.<br>

<b>comment: </b>Sequences from the PIR or PDB databases will return "n/a" for this function since they do not have an  NCBI accession.
Instead, use SHoundGetDeflineList to retrieve the accessions for these sequences.

The order in the lists is not maintained<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of integer GI identifiers<br>
<b>return: </b>pointer to a ValNode linked list of string accessions or NULL<br>

<b>prototype: </b>ValNodePtr SHoundAccFromGiList(ValNodePtr pvnGi);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of integer GI identifiers<br>
<b>return: </b>pointer to an STL list of string accessions or to an empty list<br>

<b>prototype: </b>list<string> *SHoundAccFromGiList(list<int>& stlGi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of GI identifiers<br>

<b>return: </b>comma delimited  list of accessions or zero<br>
<b>example: </b>SHoundAccFromGiList("123,34634");<br>
<a href=apifunctslist.html#SHoundAccFromGiList>list of functions</a><br><br>

<br><h2><a name=SHoundFindAcc>SHoundFindAcc</a></h2>

<br><b>description: </b>Converts an accession number for a sequence into a GenInfo identifier - GI.  This function name is deprecated
and should be replaced by SHoundGiFromGBAcc.<br>
<b>comment: </b>This function will not accept a version number (e.g. NP_116609.1).  The '.1'  must be removed from the example version
number to form a valid accession.  SeqHound only stores and returns the latest version of a sequence record.<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing accession number<br>

<b>return: </b>GI identifier, -1 if not found or zero<br>
<b>prototype: </b>Int4 SHoundFindAcc(CharPtr pcAcc);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>string containing accession number<br>
<b>return: </b>integer GI value or an error code; SEQHOUND_ERROR or SEQHOUND_ABNORMAL  if an error occurred, SEQHOUND_NULL if the value was not found in
 the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundFindAcc(string account);<br>
<br><br><b>PERL</b><br>

<b>arguments: </b>accession number<br>
<b>return: </b>GI identifier or zero<br>
<b>example: </b>SHoundFindAcc("CAA28783");<br>

<a href=apifunctslist.html#SHoundFindAcc>list of functions</a><br><br>

<br><h2><a name=SHoundFindAccList>SHoundFindAccList</a></h2>

<br><b>description: </b>Converts a list of accession numbers into a list of GI identifiers.  This function has been deprecated.
Developers should use SHoundGiFromGBAccKeyedList instead.<br>
<b>comment: </b>This function will not accept a version number (e.g. NP_116609.1).  The '.1'  must be removed from the example version
number to form a valid accession.  SeqHound only stores and returns the latest version of a sequence record.

The order in the lists is not maintained<br>

<br><br><b>C</b><br>

<b>arguments: </b>pointer to a ValNode linked list of strings - accession numbers<br>
<b>return: </b>ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundFindAccList(ValNodePtr pvnAcc);<br>

<br><br><b>C++</b><br>
<b>arguments: </b>reference to an STL list of strings - accession numbers<br>
<b>return: </b>pointer to an STL list of integer GI identifiers or to an empty list<br>

<b>prototype: </b>list<int> *SHoundFindAccList(list<string>& stlAcc);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited list of accessions<br>
<b>return: </b>comma delimited list of GI identifiers or zero<br>

<b>example: </b>SHoundFindAccList("CAA28783,X66994");<br>
<a href=apifunctslist.html#SHoundFindAccList>list of functions</a><br><br>

<br><h2><a name=SHoundFindName>SHoundFindName</a></h2>
<br><b>description: </b>Converts PDB, EMBL, Swiss-Prot, PIR sequence identifier into a GI identifier. This function has been deprecated.
  Consider SHoundGiFromDbnameAndId instead.<br>

<b>comment: </b>Note that EMBL shares accession numbers with GenBank. EMBL GenInfo identifiers may be returned using these accessions;
for example SHoundFindAcc(X13776) will return GI 45269.  EMBL also has its own identifiers (which the NCBI and SeqHound refer to as
'name').  So the same
GI may be returned by SHoundFindName(PAAMIR).<br>
<br><br><b>C</b><br>
<b>arguments: </b>pointer to a string containing sequence name<br>
<b>return: </b>integer GI identifier, -1 if not found or zero<br>

<b>prototype: </b>Int4 SHoundFindName(CharPtr pName);<br>
<br><br><b>C++</b><br>
<b>arguments: </b>string containing sequence name<br>

<b>return: </b>integer GI identifier or an error code; SEQHOUND_ERROR or  SEQHOUND_ABNORMAL if an error occurred, SEQHOUND_NULL if the value was not
found in the database, WWWGETFILE_ERROR if a transmission error occurred<br>
<b>prototype: </b>int SHoundFindName(string name);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>sequence name<br>

<b>return: </b>GI identifier or zero<br>
<b>example: </b>SHoundFindName("3TS1");<br>
<a href=apifunctslist.html#SHoundFindName>list of functions</a><br><br>

<br><h2><a name=SHoundFindNameList>SHoundFindNameList</a></h2>

<br><b>description: </b>Converts PDB, EMBL, Swiss-Prot, PIR sequence identifier into a GI identifier.  This function has been
deprecated.  Consider SHoundGiFromDbnameAndIdKeyedList instead.<br>
<b>comment: </b>Note that EMBL shares accession numbers with GenBank. EMBL GenInfo identifiers may be returned using these accessions;
for example SHoundFindAcc(X13776) will return GI 45269.  EMBL also has its own identifiers (which the NCBI and SeqHound refer to as
'name').  So the same GI may be returned by SHoundFindName(PAAMIR).<br>

<br><br><b>C</b><br>
<b>arguments: </b>pointer to a ValNode linked list of string sequence names<br>

<b>return: </b>pointer to a ValNode linked list of integer GI identifiers or NULL<br>
<b>prototype: </b>ValNodePtr SHoundFindNameList(ValNodePtr pvnName);<br>
<br><br><b>C++</b><br>

<b>arguments: </b>reference to an STL list of string sequence names<br>
<b>return: </b>pointer to an STL list of integer GI identifier or to an empty list<br>
<b>prototype: </b>list<int> *SHoundFindNameList(list<string>& stlAcc);<br>

<br><br><b>PERL</b><br>
<b>arguments: </b>comma delimited  list of sequence names<br>
<b>return: </b>comma delimited  list of GI identifiers or zero<br>

<b>example: </b>SHoundFindNameList("PMY14796,S36449,3TS1");<br>
<a href=apifunctslist.html#SHoundFindNameList>list of functions</a><br><br>

<br><h2><a name=SHoundGetNameByGi>SHoundGetNameByGi</a></h2>
<br><b>description: </b>Retrieves the Protein Data Bank (PDB) code from the given GI. This function has been deprecated.  Use
SHoundDbNameAndIdFromGi(KeyedList) instead.<br>


<br><br><b>C</b><br>
<b>arguments: </b>integer GI identifier<br>
<b>return: </b>PDB code (e.g. 3TS1) or zero if error<br>

<b>prototype: </b>CharPtr  SHoundGetNameByGi(Int4 gi);<br>
<br><br><b>PERL</b><br>
<b>arguments: </b>GI identifier<br>

<b>return: </b>PDB code (e.g. 3TS1) or zero if failure<br>
<b>example: </b>$a = SHoundGetNameByGi(230940);<br>
<a href=apifunctslist.html#SHoundGetNameByGi>list of functions</a><br><br>
